import { useState, useEffect } from 'react';
import {
  Container,
  Typography,
  Paper,
  Grid,
  TextField,
  Button,
  Box,
  Stepper,
  Step,
  StepLabel,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  Card,
  CardContent,
  LinearProgress,
  Chip,
  Divider,
  List,
  ListItem,
  ListItemText,
  CircularProgress,
  IconButton,
  Tooltip,
  Switch,
  FormControlLabel,
  Tab,
  Tabs,
  Avatar,
  ListItemAvatar,
  Drawer,
  Dialog,
  DialogContent,
  DialogTitle,
  DialogActions,
  Skeleton,
} from '@mui/material';
import type { SelectChangeEvent } from '@mui/material';
import { motion, AnimatePresence } from 'framer-motion';
import AssessmentIcon from '@mui/icons-material/Assessment';
import SecurityIcon from '@mui/icons-material/Security';
import WarningIcon from '@mui/icons-material/Warning';
import ErrorIcon from '@mui/icons-material/Error';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import DownloadIcon from '@mui/icons-material/Download';
import SaveIcon from '@mui/icons-material/Save';
import CheckIcon from '@mui/icons-material/Check';
import HourglassEmptyIcon from '@mui/icons-material/HourglassEmpty';
import ArrowForwardIosIcon from '@mui/icons-material/ArrowForwardIos';
import ArrowBackIosIcon from '@mui/icons-material/ArrowBackIos';
import InfoIcon from '@mui/icons-material/Info';
import SendIcon from '@mui/icons-material/Send';
import SmartToyIcon from '@mui/icons-material/SmartToy';
import PersonIcon from '@mui/icons-material/Person';
import AddIcon from '@mui/icons-material/Add';
import HistoryIcon from '@mui/icons-material/History';
import TrendingDownIcon from '@mui/icons-material/TrendingDown';
import AutoFixHighIcon from '@mui/icons-material/AutoFixHigh';
import DeveloperModeIcon from '@mui/icons-material/DeveloperMode';
import ChatBubbleOutlineIcon from '@mui/icons-material/ChatBubbleOutline';
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { styled } from '@mui/material/styles';
import ChatbotService from '../services/chatbotService';
import { projectService } from '../services/projectService';
import { alpha } from '@mui/material/styles';
// Use public folder for visual image
const visualImage = '/visual.png';
import { RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, Radar, ResponsiveContainer, Legend } from 'recharts';
import RiskContextBadge from '../components/RiskContextBadge';
import LockIcon from '@mui/icons-material/Lock';
import LockOpenIcon from '@mui/icons-material/LockOpen';
import { useAuth } from '../contexts/AuthContext';
import { RiskMitigationSection } from '../components/risk-mitigation';

interface ProjectInfo {
  // Section 1: Basic Project Information
  projectDuration: string;
  projectType: string;
  hasCyberLegalTeam: string;
  companyScale: string;
  projectPhase: string;

  // Section 2: Project Structure
  layer1Teams: string;
  layer2Teams: string;
  layer3Teams: string;
  teamOverlap: string;

  // Section 3: Technical Factors
  hasITTeam: string;
  devicesWithFirewall: string;
  networkType: string;
  phishingFailRate: string;

  // Section 4: Security Practices
  governanceLevel: string;
  allowPasswordReuse: string;
  usesMFA: string;

  // Additional fields
  regulatoryRequirements: string;
  stakeholderCount: string;
  thirdPartyVendors: string;
  remoteWorkLevel: string;
  cloudServices: string;
  dataClassification: string;
  bmsIntegration: string;
  accessControl: string;
  securityMonitoring: string;
  incidentResponse: string;
  backupStrategy: string;
  securityCertifications: string;
  securityAwareness: string;
  securityTeamSize: string;
  thirdPartySecurityReq: string;
  securityBudget: string;
}

interface RiskAnalysis {
  score: number;
  level: 'low' | 'medium' | 'high' | 'critical';
  recommendations: string[];
}

interface RiskResults {
  ransomware: RiskAnalysis;
  phishing: RiskAnalysis;
  dataBreach: RiskAnalysis;
  insiderAttack: RiskAnalysis;
  supplyChain: RiskAnalysis;
}

interface AutoTableUserOptions {
  startY: number;
  head: string[][];
  body: (string | number)[][];
  theme: string;
  styles: { fontSize: number };
  headStyles: { fillColor: number[] };
  columnStyles?: { [key: number]: { cellWidth: number } };
}

interface ExtendedJsPDF extends jsPDF {
  lastAutoTable: {
    finalY: number;
  };
}

interface Message {
  id: number;
  text: string;
  sender: 'user' | 'ai';
  timestamp: Date;
}

interface Conversation {
  id: number;
  title: string;
  messages: Message[];
  lastUpdated: Date;
}

interface RiskReduction {
  parameter: string;
  currentValue: string;
  suggestedValue: string;
  impact: string;
  riskReduction: number;
  changeable: boolean;
  parameterKey: string;
}

interface ChangeableProperty {
  key: string;
  label: string;
  description: string;
  changeable: boolean;
}

interface RiskMitigationRound {
  roundNumber: number;
  features: string[];
  currentRisk: number;
  projectedRisk: number;
  riskReduction: number;
  reductionPercentage: number;
  recommendations: RiskMitigationRecommendation[];
}

interface RiskMitigationRecommendation {
  featureGroup: string;
  featureName: string;
  currentOption: string;
  recommendedOption: string;
  optionIndex: number;
  description: string;
  enhancedDescription?: string;
  costLevel?: number; // 1-4 scale for $ to $$$$

  importance?: string;
}

interface RiskMitigationStrategy {
  initialRisk: number;
  finalRisk: number;
  totalReduction: number;
  totalReductionPercentage: number;
  rounds: RiskMitigationRound[];
  implementationPriority: 'high' | 'medium' | 'low';
}

// API service for risk calculation
const riskApiService = {
  calculateRisk: async (projectInfo: ProjectInfo): Promise<RiskResults> => {
    try {
      // Convert project info to model input array exactly matching the training data values
      const modelInput = [
        // 1.1 Project Duration (0-4 scale)
        ['<=3m', '3-6m', '6-12m', '12-24m', '>24m']
          .indexOf(projectInfo.projectDuration),

        // 1.2 Project Type (0-5 scale)
        ['transportation', 'government', 'healthcare', 'commercial', 'residential', 'other']
          .indexOf(projectInfo.projectType),

        // 1.3 Has Cyber Legal Team (0-2 scale)
        ['yes', 'no', 'unsure'].indexOf(projectInfo.hasCyberLegalTeam),

        // 1.4 Company Scale (0-4 scale)
        ['<=30', '31-60', '61-100', '101-150', '>150']
          .indexOf(projectInfo.companyScale),

        // 1.5 Project Phase (0-4 scale)
        ['planning', 'design', 'construction', 'maintenance', 'demolition']
          .indexOf(projectInfo.projectPhase),

        // 2.1.1 Layer 1 Teams (0-5 scale)
        ['<=10', '11-20', '21-30', '31-40', '>40', 'na']
          .indexOf(projectInfo.layer1Teams),

        // 2.1.2 Layer 2 Teams (0-5 scale)
        ['<=10', '11-20', '21-30', '31-40', '>40', 'na']
          .indexOf(projectInfo.layer2Teams),

        // 2.1.3 Layer 3 Teams (0-5 scale)
        ['<=10', '11-20', '21-30', '31-40', '>40', 'na']
          .indexOf(projectInfo.layer3Teams),

        // 2.2 Team Overlap (0-4 scale)
        ['<=20', '21-40', '41-60', '61-80', '81-100']
          .indexOf(projectInfo.teamOverlap),

        // 3.1 Has IT Team (0-2 scale)
        ['yes', 'no', 'unsure'].indexOf(projectInfo.hasITTeam),

        // 3.2 Devices with Firewall (0-4 scale)
        ['<=20', '21-40', '41-60', '61-80', '81-100']
          .indexOf(projectInfo.devicesWithFirewall),

        // 3.3 Network Type (0-2 scale)
        ['public', 'private', 'both'].indexOf(projectInfo.networkType),

        // 3.4 Phishing Fail Rate (0-4 scale)
        ['<=20', '21-40', '41-60', '61-80', '81-100']
          .indexOf(projectInfo.phishingFailRate),

        // 4.1 Governance Level (0-4 scale)
        ['level1', 'level2', 'level3', 'level4', 'level5']
          .indexOf(projectInfo.governanceLevel),

        // 4.2 Allow Password Reuse (0-1 scale)
        ['yes', 'no'].indexOf(projectInfo.allowPasswordReuse),

        // 4.3 Uses MFA (0-1 scale)
        ['yes', 'no'].indexOf(projectInfo.usesMFA)
      ];

      // Validate that we have exactly 16 numbers
      if (modelInput.length !== 16) {
        throw new Error(`Invalid input: expected 16 numbers, got ${modelInput.length}`);
      }

      // Validate that all inputs are numbers and within their expected ranges
      const validations = [
        { value: modelInput[0], min: 0, max: 4, name: "1.1 Project Duration" },
        { value: modelInput[1], min: 0, max: 5, name: "1.2 Project Type" },
        { value: modelInput[2], min: 0, max: 2, name: "1.3 Cyber Legal Team" },
        { value: modelInput[3], min: 0, max: 4, name: "1.4 Company Scale" },
        { value: modelInput[4], min: 0, max: 4, name: "1.5 Project Phase" },
        { value: modelInput[5], min: 0, max: 5, name: "2.1.1 Layer 1 Teams" },
        { value: modelInput[6], min: 0, max: 5, name: "2.1.2 Layer 2 Teams" },
        { value: modelInput[7], min: 0, max: 5, name: "2.1.3 Layer 3 Teams" },
        { value: modelInput[8], min: 0, max: 4, name: "2.2 Team Overlap" },
        { value: modelInput[9], min: 0, max: 2, name: "3.1 IT Team" },
        { value: modelInput[10], min: 0, max: 4, name: "3.2 Devices with Firewall" },
        { value: modelInput[11], min: 0, max: 2, name: "3.3 Network Type" },
        { value: modelInput[12], min: 0, max: 4, name: "3.4 Phishing Fail Rate" },
        { value: modelInput[13], min: 0, max: 4, name: "4.1 Governance Level" },
        { value: modelInput[14], min: 0, max: 1, name: "4.2 Password Reuse" },
        { value: modelInput[15], min: 0, max: 1, name: "4.3 MFA" }
      ];

      for (const validation of validations) {
        if (typeof validation.value !== 'number' || isNaN(validation.value)) {
          throw new Error(`Invalid input: ${validation.name} must be a number`);
        }
        if (validation.value < validation.min || validation.value > validation.max) {
          throw new Error(`Invalid input: ${validation.name} must be between ${validation.min} and ${validation.max}`);
        }
      }

      console.log('Sending data to API:', modelInput);
      const response = await fetch('http://localhost:8000/predict-simple', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ user_data: modelInput }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('API Error:', errorData);
        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      console.log('API Response:', data);
      const probabilities = data.probabilities;
      
      // Convert probabilities to risk levels and recommendations
      const convertToRiskLevel = (prob: number): 'low' | 'medium' | 'high' | 'critical' => {
        if (prob < 0.3) return 'low';
        if (prob < 0.6) return 'medium';
        if (prob < 0.85) return 'high';
        return 'critical';
      };

      const getRecommendations = (riskType: string, level: string): string[] => {
        const baseRecommendations = {
          low: ['Regular monitoring and basic security measures'],
          medium: ['Enhanced security protocols', 'Regular staff training'],
          high: ['Immediate security assessment', 'Advanced protection measures', 'Incident response plan'],
          critical: ['Urgent security overhaul', 'Expert consultation', 'Comprehensive risk mitigation plan']
        };
        return baseRecommendations[level as keyof typeof baseRecommendations];
      };
      
      return {
        ransomware: {
          score: Math.round(probabilities[0] * 100),
          level: convertToRiskLevel(probabilities[0]),
          recommendations: getRecommendations('ransomware', convertToRiskLevel(probabilities[0]))
        },
        phishing: {
          score: Math.round(probabilities[1] * 100),
          level: convertToRiskLevel(probabilities[1]),
          recommendations: getRecommendations('phishing', convertToRiskLevel(probabilities[1]))
        },
        dataBreach: {
          score: Math.round(probabilities[2] * 100),
          level: convertToRiskLevel(probabilities[2]),
          recommendations: getRecommendations('dataBreach', convertToRiskLevel(probabilities[2]))
        },
        insiderAttack: {
          score: Math.round(probabilities[3] * 100),
          level: convertToRiskLevel(probabilities[3]),
          recommendations: getRecommendations('insiderAttack', convertToRiskLevel(probabilities[3]))
        },
        supplyChain: {
          score: Math.round(probabilities[4] * 100),
          level: convertToRiskLevel(probabilities[4]),
          recommendations: getRecommendations('supplyChain', convertToRiskLevel(probabilities[4]))
        }
      };
    } catch (error) {
      console.error('Risk calculation error:', error);
      throw error;
    }
  },

  checkHealth: async (): Promise<{ status: string; modelLoaded?: boolean }> => {
    const response = await fetch('http://localhost:8000/health');
    return response.json();
  }
};

const TooltipContent = styled('div')({
  '& p': {
    margin: '8px 0',
  },
  '& ul': {
    margin: '4px 0',
    paddingLeft: '20px',
  },
  '& li': {
    margin: '4px 0',
  }
});

const PulsingLoader = styled(CircularProgress)(({ theme }) => ({
  animation: 'pulse 1.5s ease-in-out infinite',
  '@keyframes pulse': {
    '0%': {
      opacity: 1,
      transform: 'scale(1)',
    },
    '50%': {
      opacity: 0.7,
      transform: 'scale(1.1)',
    },
    '100%': {
      opacity: 1,
      transform: 'scale(1)',
    },
  },
}));

const TypingAnimation = styled(Box)(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  gap: '4px',
  padding: '8px 12px',
  '& .dot': {
    width: '8px',
    height: '8px',
    borderRadius: '50%',
    backgroundColor: theme.palette.text.secondary,
    animation: 'typing 1.4s infinite ease-in-out',
    '&:nth-of-type(1)': { animationDelay: '0s' },
    '&:nth-of-type(2)': { animationDelay: '0.2s' },
    '&:nth-of-type(3)': { animationDelay: '0.4s' },
  },
  '@keyframes typing': {
    '0%, 60%, 100%': {
      transform: 'scale(1)',
      opacity: 0.5,
    },
    '30%': {
      transform: 'scale(1.2)',
      opacity: 1,
    },
  },
}));

const RiskQuantification = () => {
  const { isAdmin } = useAuth();
  const [activeSection, setActiveSection] = useState(0);
  const [slideDirection, setSlideDirection] = useState(0); // -1 for left, 1 for right
  const [projectInfo, setProjectInfo] = useState<ProjectInfo>({
    projectDuration: '', projectType: '', hasCyberLegalTeam: '', companyScale: '', projectPhase: '',
    layer1Teams: '', layer2Teams: '', layer3Teams: '', teamOverlap: '', hasITTeam: '', devicesWithFirewall: '', networkType: '',
    phishingFailRate: '', governanceLevel: '', allowPasswordReuse: '', usesMFA: '',
    regulatoryRequirements: '', stakeholderCount: '', thirdPartyVendors: '', remoteWorkLevel: '',
    cloudServices: '', dataClassification: '', bmsIntegration: '', accessControl: '',
    securityMonitoring: '', incidentResponse: '', backupStrategy: '', securityCertifications: '',
    securityAwareness: '', securityTeamSize: '', thirdPartySecurityReq: '', securityBudget: ''
  });

  const [isLoading, setIsLoading] = useState(false);
  const [apiError, setApiError] = useState<string | null>(null);
  const [riskResults, setRiskResults] = useState<RiskResults>({
    ransomware: {
      score: 0,
      level: 'low',
      recommendations: []
    },
    phishing: {
      score: 0,
      level: 'low',
      recommendations: []
    },
    dataBreach: {
      score: 0,
      level: 'low',
      recommendations: []
    },
    insiderAttack: {
      score: 0,
      level: 'low',
      recommendations: []
    },
    supplyChain: {
      score: 0,
      level: 'low',
      recommendations: []
    }
  });

  const [useRandomResults, setUseRandomResults] = useState(false);
  const [devMode, setDevMode] = useState(false);

  // Chatbot state
  const [conversations, setConversations] = useState<Conversation[]>([
    {
      id: 1,
      title: 'Risk Analysis Chat',
      messages: [{
        id: 1,
        text: "Hello! I'm **Dr. CyberBuild**, your expert construction cybersecurity consultant. I specialize in analyzing cyber risks for construction projects and providing actionable security strategies. Once you complete your risk assessment, I'll have comprehensive insights about your project to offer specialized guidance. How can I assist you today?",
        sender: 'ai',
        timestamp: new Date(),
      }],
      lastUpdated: new Date(),
    }
  ]);
  const [currentConversationId, setCurrentConversationId] = useState(1);
  const [chatInput, setChatInput] = useState('');
  const [isChatSidebarOpen, setIsChatSidebarOpen] = useState(false);

  // Risk reduction state
  const [riskReductions, setRiskReductions] = useState<RiskReduction[]>([]);
  const [isAnalyzingReductions, setIsAnalyzingReductions] = useState(false);
  const [riskMitigationStrategy, setRiskMitigationStrategy] = useState<RiskMitigationStrategy | null>(null);
  const [selectedRound, setSelectedRound] = useState(0);
  const [preservedRound, setPreservedRound] = useState<number>(0);
  const [appliedRecommendations, setAppliedRecommendations] = useState<Set<string>>(new Set());
  const [applyingRecommendation, setApplyingRecommendation] = useState<string | null>(null);
  const [isUpdatingStrategy, setIsUpdatingStrategy] = useState(false);
  const [lockedRecommendations, setLockedRecommendations] = useState<Set<string>>(new Set());
  const [enhancedDescriptions, setEnhancedDescriptions] = useState<Map<string, RiskMitigationRecommendation>>(new Map());
  const [loadingRecommendations, setLoadingRecommendations] = useState<Set<string>>(new Set());
  const [allRecommendationsLoaded, setAllRecommendationsLoaded] = useState<boolean>(false);

  // Changeable properties state
  const [changeableProperties, setChangeableProperties] = useState<ChangeableProperty[]>([
    {
      key: 'usesMFA',
      label: 'Multi-Factor Authentication',
      description: 'Enable MFA for system access',
      changeable: true
    },
    {
      key: 'allowPasswordReuse',
      label: 'Password Reuse Policy',
      description: 'Implement password reuse restrictions',
      changeable: true
    },
    {
      key: 'devicesWithFirewall',
      label: 'Firewall Coverage',
      description: 'Increase firewall deployment across devices',
      changeable: true
    },
    {
      key: 'governanceLevel',
      label: 'Governance Level',
      description: 'Improve security governance practices',
      changeable: true
    },
    {
      key: 'hasITTeam',
      label: 'IT Team Presence',
      description: 'Establish dedicated IT team',
      changeable: false
    },
    {
      key: 'networkType',
      label: 'Network Infrastructure',
      description: 'Modify network architecture',
      changeable: false
    },
    {
      key: 'phishingFailRate',
      label: 'Security Training Effectiveness',
      description: 'Improve security awareness training',
      changeable: true
    }
  ]);

  // Active tab state for the new section
  const [activeTab, setActiveTab] = useState(0);

  // Add new state for chatbot service
  const [chatbotService, setChatbotService] = useState<ChatbotService | null>(null);
  const [isChatInitialized, setIsChatInitialized] = useState(false);
  const [isVisualDialogOpen, setIsVisualDialogOpen] = useState(false);
  const [showRiskNumbers, setShowRiskNumbers] = useState(false);
  const [isAiTyping, setIsAiTyping] = useState(false);

  // Save project state
  const [saveDialogOpen, setSaveDialogOpen] = useState(false);
  const [projectName, setProjectName] = useState('');
  const [isSaving, setIsSaving] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const [saveSuccess, setSaveSuccess] = useState(false);

  // Recommended questions state
  const [recommendedQuestions, setRecommendedQuestions] = useState<string[]>([
    'Analyze my construction project cyber risks',
    'What are the most critical vulnerabilities?',
    'How should I secure my project network?',
    'What vendor security requirements should I enforce?',
    'How can I protect BIM and project data?',
    'What incident response plan do I need?',
    'How do I secure construction site IoT devices?',
    'What compliance standards apply to my project?'
  ]);
  const [isLoadingQuestions, setIsLoadingQuestions] = useState(false);

  const sections = ['Basic Info', 'Structure', 'Technical', 'Security'];
  const sectionDescriptions = [
    'The Overall Information of the Project - This section collects the overall information of the project through all phases. It is suggested that a project manager familiar with the overall project finish this section.',
    'The Structure of a Construction Project - The statistical structural features of a project, such as the number of teams and teams overlapping, provide valuable insights into the project\'s composition and communication patterns. It is suggested to finish this section by a project manager.',
    'IT Factors - The IT features set focuses on digital assets, such as hardware, software, and data, and the people who operate on them. When completing this section, please focus on the phase of the project you are involved in and consider both your team and any subcontractors. It is advisable to collaborate with an IT professional.',
    'Management and Human Factors - These factors include leadership commitment, workforce knowledge, corporate governance, ethical practices, and stakeholder engagement. They establish a strong cybersecurity foundation and promote a culture of security within the project. It is suggested to be completed by a project manager from your company involved in this project.'
  ];

  // Component to properly render formatted message content
  const MessageContent = ({ message }: { message: Message }) => {
    const formatMessageText = (text: string) => {
      // Handle the formatted text from our enhanced formatResponse method
      const parts: React.ReactNode[] = [];
      let currentIndex = 0;
      
      // Regular expression to match various formatting patterns
      const formatRegex = /<strong[^>]*>(.*?)<\/strong>|<em>(.*?)<\/em>|(\*[^*]*(?:IMMEDIATE|URGENT|CRITICAL)[^*]*\*)|(\n• .*?)(?=\n|$)|(\n\d+\. .*?)(?=\n|$)/g;
      
      let match;
      while ((match = formatRegex.exec(text)) !== null) {
        // Add text before the match
        if (match.index > currentIndex) {
          const beforeText = text.slice(currentIndex, match.index);
          if (beforeText.trim()) {
            parts.push(<span key={`text-${match.index}`}>{beforeText}</span>);
          }
        }
        
        if (match[1]) {
          // Bold text (strong)
          parts.push(<strong key={`bold-${match.index}`}>{match[1]}</strong>);
        } else if (match[2]) {
          // Italic text (em)
          parts.push(<em key={`italic-${match.index}`}>{match[2]}</em>);
        } else if (match[3]) {
          // Urgent action markers
          parts.push(
            <Box 
              key={`urgent-${match.index}`}
              component="span" 
              sx={{ 
                color: '#d32f2f', 
                fontWeight: 'bold',
                backgroundColor: 'rgba(211, 47, 47, 0.1)',
                padding: '2px 6px',
                borderRadius: '4px',
                display: 'inline-block',
                margin: '2px 0',
                fontSize: '0.9em'
              }}
            >
              {match[3]}
            </Box>
          );
        } else if (match[4]) {
          // Bullet points
          parts.push(
            <Box key={`bullet-${match.index}`} component="div" sx={{ ml: 2, my: 0.5, lineHeight: 1.4 }}>
              {match[4].trim()}
            </Box>
          );
        } else if (match[5]) {
          // Numbered lists
          parts.push(
            <Box key={`numbered-${match.index}`} component="div" sx={{ ml: 2, my: 0.5, lineHeight: 1.4 }}>
              {match[5].trim()}
            </Box>
          );
        }
        
        currentIndex = match.index + match[0].length;
      }
      
      // Add remaining text
      if (currentIndex < text.length) {
        const remainingText = text.slice(currentIndex);
        if (remainingText.trim()) {
          parts.push(<span key="remaining">{remainingText}</span>);
        }
      }
      
      // If no special formatting found, fall back to simple bold/italic parsing
      if (parts.length === 0) {
        return text
          .split(/(\*\*.*?\*\*|\*.*?\*)/g)
          .map((part, index) => {
            if (part.startsWith('**') && part.endsWith('**')) {
              return <strong key={`fallback-bold-${index}`}>{part.slice(2, -2)}</strong>;
            } else if (part.startsWith('*') && part.endsWith('*') && !part.includes('IMMEDIATE') && !part.includes('URGENT') && !part.includes('CRITICAL')) {
              return <em key={`fallback-italic-${index}`}>{part.slice(1, -1)}</em>;
            }
            return <span key={`fallback-text-${index}`}>{part}</span>;
          });
      }
      
      return parts;
    };

    // Handle line breaks and create proper paragraph structure
    const lines = message.text.split('\n');
    const formattedContent = lines.map((line, lineIndex) => {
      if (line.trim() === '') {
        return <br key={`br-${lineIndex}`} />;
      }
      
      const formattedLine = formatMessageText(line);
      return (
        <Box key={`line-${lineIndex}`} component="span" sx={{ display: 'block', mb: line.includes('•') || line.match(/^\d+\./) ? 0 : 0.5 }}>
          {formattedLine}
        </Box>
      );
    });

    return <>{formattedContent}</>;
  };

  const generateRandomResults = (): RiskResults => {
    // Helper to generate a score more likely to be high/critical
    const weightedScore = () => {
      const r = Math.random();
      if (r < 0.1) return Math.floor(30 + Math.random() * 30); // 10% medium (30-59)
      if (r < 0.7) return Math.floor(60 + Math.random() * 25); // 60% high (60-84)
      return Math.floor(85 + Math.random() * 15); // 30% critical (85-99)
    };
    const getLevel = (score: number): 'low' | 'medium' | 'high' | 'critical' => {
      if (score < 30) return 'low';
      if (score < 60) return 'medium';
      if (score < 85) return 'high';
      return 'critical';
    };
    const recommendations = [
      'Implement basic cybersecurity measures',
      'Conduct regular security audits',
      'Update security policies and procedures'
    ];
    return {
      ransomware: (() => { const score = weightedScore(); return { score, level: getLevel(score), recommendations }; })(),
      phishing: (() => { const score = weightedScore(); return { score, level: getLevel(score), recommendations }; })(),
      dataBreach: (() => { const score = weightedScore(); return { score, level: getLevel(score), recommendations }; })(),
      insiderAttack: (() => { const score = weightedScore(); return { score, level: getLevel(score), recommendations }; })(),
      supplyChain: (() => { const score = weightedScore(); return { score, level: getLevel(score), recommendations }; })(),
    };
  };

  const updateRiskScores = async () => {
    setIsLoading(true);
    setApiError(null);
    
    try {
      if (useRandomResults) {
        const results = generateRandomResults();
        setRiskResults(results);
      } else {
        const results = await riskApiService.calculateRisk(projectInfo);
        setRiskResults(results);
      }
    } catch (error) {
      console.error('Risk calculation failed:', error);
      setApiError((error as Error).message || 'Failed to calculate risk scores');
    } finally {
      setIsLoading(false);
    }
  };

  const handleInputChange = (field: keyof ProjectInfo) => async (
    event: SelectChangeEvent<string>
  ) => {
    const updatedProjectInfo = {
      ...projectInfo,
      [field]: event.target.value,
    };
    setProjectInfo(updatedProjectInfo);
    
    // Only update risk scores if form is complete
    const requiredFields = [
      'projectDuration', 'projectType', 'hasCyberLegalTeam', 'companyScale', 'projectPhase',
      'teamOverlap', 'hasITTeam', 'devicesWithFirewall', 'networkType', 'phishingFailRate',
      'governanceLevel', 'allowPasswordReuse', 'usesMFA'
    ];
    
    const basicFieldsComplete = requiredFields.every(field => 
      updatedProjectInfo[field as keyof ProjectInfo] && updatedProjectInfo[field as keyof ProjectInfo] !== ''
    );
    
    const hasAtLeastOneTeam = [1, 2, 3].some(layer => {
      const value = updatedProjectInfo[`layer${layer}Teams` as keyof ProjectInfo];
      return value && value !== 'na' && value !== '';
    });
    
    if (basicFieldsComplete && hasAtLeastOneTeam) {
      setIsLoading(true);
      setApiError(null);
      
      try {
        if (useRandomResults) {
          const results = generateRandomResults();
          setRiskResults(results);
        } else {
          const results = await riskApiService.calculateRisk(updatedProjectInfo);
          setRiskResults(results);
        }
        
        // Also regenerate mitigation strategy if it exists
        if (riskMitigationStrategy) {
          console.log('🔄 Form field changed - regenerating mitigation strategy');
          await generateMitigationWithUpdatedData(updatedProjectInfo);
        }
        
      } catch (error) {
        console.error('Risk calculation failed:', error);
        setApiError((error as Error).message || 'Failed to calculate risk scores');
      } finally {
        setIsLoading(false);
      }
    }
  };

  const handleNext = () => {
    setSlideDirection(1);
    setActiveSection((prev) => Math.min(prev + 1, sections.length - 1));
  };

  const handleBack = () => {
    setSlideDirection(-1);
    setActiveSection((prev) => Math.max(prev - 1, 0));
  };

  const getRiskColor = (level: string): string => {
    switch (level) {
      case 'low':
        return '#4caf50';
      case 'medium':
        return '#ff9800';
      case 'high':
        return '#f44336';
      case 'critical':
        return '#d32f2f';
      default:
        return '#757575';
    }
  };

  const getRiskLevelColor = (level: string): 'success' | 'warning' | 'error' | 'info' => {
    switch (level) {
      case 'low':
        return 'success';
      case 'medium':
        return 'warning';
      case 'high':
      case 'critical':
        return 'error';
      default:
        return 'info';
    }
  };

  const getRiskLevelIcon = (level: string) => {
    switch (level) {
      case 'low':
        return <CheckCircleIcon />;
      case 'medium':
        return <WarningIcon />;
      case 'high':
        return <ErrorIcon />;
      case 'critical':
        return <ErrorIcon />;
      default:
        return <SecurityIcon />;
    }
  };

  const exportToPDF = () => {
    try {
      const doc = new jsPDF() as ExtendedJsPDF;
      const pageWidth = doc.internal.pageSize.width;
      const pageHeight = doc.internal.pageSize.height;
      const margin = 20;
      const contentWidth = pageWidth - (margin * 2);
      
      // Modern color palette
      const colors = {
        primary: [79, 70, 229] as [number, number, number], // Indigo
        primaryLight: [129, 140, 248] as [number, number, number],
        secondary: [71, 85, 105] as [number, number, number],
        accent: [16, 185, 129] as [number, number, number],
        success: [34, 197, 94] as [number, number, number],
        warning: [245, 158, 11] as [number, number, number],
        error: [239, 68, 68] as [number, number, number],
        critical: [185, 28, 28] as [number, number, number],
        text: [15, 23, 42] as [number, number, number],
        textLight: [100, 116, 139] as [number, number, number],
        background: [248, 250, 252] as [number, number, number],
        white: [255, 255, 255] as [number, number, number],
        gray: [226, 232, 240] as [number, number, number]
      };

      let currentY = margin;

      // Helper function to check if we need a new page
      const checkPageBreak = (neededSpace: number) => {
        if (currentY + neededSpace > pageHeight - 50) {
          doc.addPage();
          currentY = margin;
          return true;
        }
        return false;
      };

      // Modern header
      const addModernHeader = (title: string, subtitle?: string) => {
        checkPageBreak(70);
        
        // Header background
        doc.setFillColor(colors.primary[0], colors.primary[1], colors.primary[2]);
        doc.rect(0, currentY, pageWidth, 50, 'F');
        
        // Title
        doc.setTextColor(colors.white[0], colors.white[1], colors.white[2]);
        doc.setFontSize(20);
        doc.setFont('helvetica', 'bold');
        doc.text(title, margin, currentY + 20);
        
        // Subtitle
        if (subtitle) {
          doc.setFontSize(11);
          doc.setFont('helvetica', 'normal');
          doc.text(subtitle, margin, currentY + 35);
        }
        
        currentY += 60;
      };

      // Section header
      const addSectionHeader = (text: string) => {
        checkPageBreak(35);
        
        // Section background
        doc.setFillColor(colors.background[0], colors.background[1], colors.background[2]);
        doc.rect(margin, currentY, contentWidth, 25, 'F');
        
        // Accent line
        doc.setFillColor(colors.accent[0], colors.accent[1], colors.accent[2]);
        doc.rect(margin, currentY, 4, 25, 'F');
        
        // Section text
        doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text(text, margin + 15, currentY + 16);
        
        currentY += 35;
      };

      // Field row with modern styling
      const addFieldRow = (label: string, value: string, isHighlight = false) => {
        checkPageBreak(18);
        
        // Background for highlighted items
        if (isHighlight) {
          doc.setFillColor(colors.background[0], colors.background[1], colors.background[2]);
          doc.rect(margin + 5, currentY - 2, contentWidth - 10, 14, 'F');
        }
        
        // Label
        doc.setTextColor(colors.textLight[0], colors.textLight[1], colors.textLight[2]);
        doc.setFontSize(9);
        doc.setFont('helvetica', 'bold');
        doc.text(label.toUpperCase(), margin + 10, currentY + 8);
        
        // Value
        const displayValue = value || 'Not specified';
        doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        
        // Value background
        doc.setFillColor(colors.gray[0], colors.gray[1], colors.gray[2]);
        doc.rect(margin + 100, currentY + 1, contentWidth - 115, 10, 'F');
        doc.text(displayValue, margin + 105, currentY + 8);
        
        currentY += 18;
      };

      // Main Header
      addModernHeader(
        'CYBER RISK ASSESSMENT',
        'Comprehensive Security Analysis & Risk Evaluation Report'
      );

      // Executive Summary
      doc.setFillColor(colors.white[0], colors.white[1], colors.white[2]);
      doc.rect(margin, currentY, contentWidth, 40, 'F');
      doc.setDrawColor(colors.gray[0], colors.gray[1], colors.gray[2]);
      doc.rect(margin, currentY, contentWidth, 40);
      
      doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
      doc.setFontSize(11);
      doc.setFont('helvetica', 'bold');
      doc.text('EXECUTIVE SUMMARY', margin + 10, currentY + 15);
      
      const currentDate = new Date().toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
      
      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(colors.textLight[0], colors.textLight[1], colors.textLight[2]);
      doc.text(`Report Generated: ${currentDate}`, margin + 10, currentY + 25);
      
      doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
      doc.text('This assessment evaluates cybersecurity risks across organizational,', margin + 10, currentY + 32);
      doc.text('technical, and procedural domains.', margin + 10, currentY + 37);
      
      currentY += 50;

      // Project Overview Section
      addSectionHeader('PROJECT OVERVIEW');
      addFieldRow('Project Duration', projectInfo.projectDuration);
      addFieldRow('Project Type', projectInfo.projectType);
      addFieldRow('Current Phase', projectInfo.projectPhase);
      addFieldRow('Organization Size', projectInfo.companyScale, true);
      addFieldRow('Legal Team', projectInfo.hasCyberLegalTeam);

      // Organizational Structure Section
      addSectionHeader('ORGANIZATIONAL STRUCTURE');
      let hasTeamData = false;
      for (let i = 1; i <= 3; i++) {
        const value = projectInfo[`layer${i}Teams` as keyof ProjectInfo];
        if (value && value !== 'na') {
          addFieldRow(`Layer ${i} Teams`, value);
          hasTeamData = true;
        }
      }
      if (!hasTeamData) {
        doc.setTextColor(colors.textLight[0], colors.textLight[1], colors.textLight[2]);
        doc.setFontSize(10);
        doc.text('No team structure data specified', margin + 10, currentY);
        currentY += 15;
      }
      if (projectInfo.teamOverlap) {
        addFieldRow('Team Overlap', projectInfo.teamOverlap, true);
      }

      // Technical Infrastructure Section
      addSectionHeader('TECHNICAL INFRASTRUCTURE');
      addFieldRow('IT Team', projectInfo.hasITTeam);
      addFieldRow('Network Architecture', projectInfo.networkType, true);
      addFieldRow('Firewall Coverage', projectInfo.devicesWithFirewall);
      addFieldRow('Phishing Resilience', projectInfo.phishingFailRate);

      // Security Practices Section
      addSectionHeader('SECURITY PRACTICES');
      addFieldRow('Governance Maturity', projectInfo.governanceLevel, true);
      addFieldRow('Multi-Factor Auth', projectInfo.usesMFA);
      addFieldRow('Password Policy', projectInfo.allowPasswordReuse);

      // Start Risk Analysis on new page
      doc.addPage();
      currentY = margin;

      // Risk Analysis Header
      addModernHeader('RISK ANALYSIS RESULTS', 'Detailed Security Risk Assessment');

      // Risk Score Overview
      doc.setFillColor(colors.white[0], colors.white[1], colors.white[2]);
      doc.rect(margin, currentY, contentWidth, 30, 'F');
      doc.setDrawColor(colors.gray[0], colors.gray[1], colors.gray[2]);
      doc.rect(margin, currentY, contentWidth, 30);
      
      doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
      doc.setFontSize(11);
      doc.setFont('helvetica', 'bold');
      doc.text('RISK SCORE OVERVIEW', margin + 10, currentY + 20);
      
      currentY += 40;

      // Risk table header
      doc.setFillColor(colors.primary[0], colors.primary[1], colors.primary[2]);
      doc.rect(margin, currentY, contentWidth, 15, 'F');
      
      doc.setTextColor(colors.white[0], colors.white[1], colors.white[2]);
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Risk Category', margin + 10, currentY + 10);
      doc.text('Score', margin + 80, currentY + 10);
      doc.text('Level', margin + 120, currentY + 10);
      
      currentY += 20;

      // Risk rows
      Object.entries(riskResults).forEach(([risk, analysis], index) => {
        checkPageBreak(25);
        
        const riskColor = analysis.level === 'critical' ? colors.critical :
                         analysis.level === 'high' ? colors.error :
                         analysis.level === 'medium' ? colors.warning :
                         colors.success;
        
        // Row background
        const rowColor = index % 2 === 0 ? colors.background : colors.white;
        doc.setFillColor(rowColor[0], rowColor[1], rowColor[2]);
        doc.rect(margin, currentY - 2, contentWidth, 18, 'F');
        
        // Risk category
        doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        const riskName = risk.charAt(0).toUpperCase() + risk.slice(1).replace(/([A-Z])/g, ' $1');
        doc.text(riskName, margin + 10, currentY + 8);
        
        // Progress bar background
        const barWidth = 30;
        const barHeight = 8;
        const barX = margin + 80;
        const barY = currentY + 2;
        
        doc.setFillColor(colors.gray[0], colors.gray[1], colors.gray[2]);
        doc.rect(barX, barY, barWidth, barHeight, 'F');
        
        // Progress bar fill
        doc.setFillColor(riskColor[0], riskColor[1], riskColor[2]);
        const fillWidth = (analysis.score / 100) * barWidth;
        doc.rect(barX, barY, fillWidth, barHeight, 'F');
        
        // Score text
        doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
        doc.setFontSize(8);
        doc.text(`${analysis.score}%`, barX, currentY + 14);
        
        // Risk level
        doc.setTextColor(riskColor[0], riskColor[1], riskColor[2]);
        doc.setFontSize(9);
        doc.setFont('helvetica', 'bold');
        doc.text(analysis.level.toUpperCase(), margin + 120, currentY + 8);
        
        currentY += 20;
      });

      // Recommendations Section
      currentY += 20;
      addSectionHeader('STRATEGIC RECOMMENDATIONS');
      
      const recommendations = [
        { priority: 'HIGH', text: 'Implement Zero Trust Architecture', impact: 'Critical security enhancement' },
        { priority: 'HIGH', text: 'Deploy Advanced Threat Detection', impact: 'Real-time threat monitoring' },
        { priority: 'MED', text: 'Enhance Security Training Program', impact: 'Reduce human error risks' },
        { priority: 'MED', text: 'Regular Penetration Testing', impact: 'Proactive vulnerability assessment' },
        { priority: 'LOW', text: 'Update Incident Response Plan', impact: 'Improved crisis management' }
      ];

      recommendations.forEach((rec, index) => {
        checkPageBreak(20);
        
        const priorityColor = rec.priority === 'HIGH' ? colors.error :
                             rec.priority === 'MED' ? colors.warning : colors.accent;
        
        // Recommendation background
        doc.setFillColor(colors.background[0], colors.background[1], colors.background[2]);
        doc.rect(margin + 5, currentY - 2, contentWidth - 10, 16, 'F');
        
        // Priority badge
        doc.setFillColor(priorityColor[0], priorityColor[1], priorityColor[2]);
        doc.rect(margin + 10, currentY + 2, 20, 8, 'F');
        doc.setTextColor(colors.white[0], colors.white[1], colors.white[2]);
        doc.setFontSize(7);
        doc.setFont('helvetica', 'bold');
        doc.text(rec.priority, margin + 13, currentY + 7);
        
        // Recommendation text
        doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
        doc.setFontSize(9);
        doc.setFont('helvetica', 'bold');
        doc.text(`${index + 1}. ${rec.text}`, margin + 40, currentY + 6);
        
        // Impact description
        doc.setTextColor(colors.textLight[0], colors.textLight[1], colors.textLight[2]);
        doc.setFontSize(8);
        doc.setFont('helvetica', 'normal');
        doc.text(rec.impact, margin + 40, currentY + 12);
        
        currentY += 20;
      });

      // Footer for all pages
      const pageCount = (doc as any).internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        
        // Footer background
        doc.setFillColor(colors.background[0], colors.background[1], colors.background[2]);
        doc.rect(0, pageHeight - 25, pageWidth, 25, 'F');
        
        // Footer content
        doc.setTextColor(colors.textLight[0], colors.textLight[1], colors.textLight[2]);
        doc.setFontSize(8);
        doc.setFont('helvetica', 'normal');
        
        // Company branding
        doc.setFont('helvetica', 'bold');
        doc.text('CYBER RISK DASHBOARD', margin, pageHeight - 12);
        
        // Page number (centered)
        doc.setFont('helvetica', 'normal');
        doc.text(
          `Page ${i} of ${pageCount}`,
          pageWidth / 2 - 10,
          pageHeight - 12
        );
        
        // Date (right)
        doc.text(
          new Date().toLocaleDateString(), 
          pageWidth - margin - 30, 
          pageHeight - 12
        );
        
        // Decorative line
        doc.setDrawColor(colors.accent[0], colors.accent[1], colors.accent[2]);
        doc.setLineWidth(1);
        doc.line(margin, pageHeight - 20, pageWidth - margin, pageHeight - 20);
      }

      // Save the PDF
      doc.save('cyber-risk-assessment-modern.pdf');
    } catch (error) {
      console.error('Error generating PDF:', error);
    }
  };

  const RiskIndicator = ({ 
    risk, 
    analysis 
  }: { 
    risk: string; 
    analysis: RiskAnalysis;
  }) => (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.3 }}
    >
      <Card
        sx={{
            position: 'relative',
          overflow: 'hidden',
          borderRadius: 3,
          background: `linear-gradient(135deg, ${getRiskColor(analysis.level)}15, ${getRiskColor(analysis.level)}05)`,
          border: `2px solid ${getRiskColor(analysis.level)}`,
          transition: 'all 0.3s ease-in-out',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: `0 8px 25px ${getRiskColor(analysis.level)}40`,
          }
        }}
      >
        <CardContent sx={{ p: 2, textAlign: 'center' }}>
          {/* Risk Category Title */}
          <Typography 
            variant="subtitle1" 
            fontWeight="bold" 
              sx={{ 
              mb: 1.5,
              color: 'text.primary',
              fontSize: '0.95rem'
            }}
          >
            {risk.charAt(0).toUpperCase() + risk.slice(1).replace(/([A-Z])/g, ' $1')}
          </Typography>

          {/* Risk Level/Score Display */}
          <Box sx={{ position: 'relative', mb: 1.5 }}>
              <Box
                sx={{
                width: 60,
                height: 60,
                  borderRadius: '50%',
                background: `linear-gradient(135deg, ${getRiskColor(analysis.level)}, ${getRiskColor(analysis.level)}CC)`,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                margin: '0 auto',
                boxShadow: `0 4px 20px ${getRiskColor(analysis.level)}40`,
                position: 'relative',
                '&::before': {
                  content: '""',
                  position: 'absolute',
                  inset: 2,
                  borderRadius: '50%',
                  background: 'rgba(255,255,255,0.2)',
                  backdropFilter: 'blur(10px)',
                }
                }}
              >
                <motion.div
                key={showRiskNumbers ? analysis.score : analysis.level}
                  initial={{ opacity: 0, scale: 0.5 }}
                  animate={{ opacity: 1, scale: 1 }}
                  transition={{ duration: 0.3 }}
                style={{
                  position: 'relative',
                  zIndex: 1,
                  color: 'white',
                  fontWeight: 'bold',
                  textAlign: 'center',
                  textShadow: '0 2px 4px rgba(0,0,0,0.3)'
                }}
              >
                {showRiskNumbers ? (
          <Typography
                    variant="h4" 
                    component="div" 
            sx={{ 
                      lineHeight: 1, 
                      fontWeight: 'bold',
                      fontSize: '1.8rem'
            }}
          >
                    {Math.round(analysis.score)}%
                  </Typography>
                ) : (
                  <Typography variant="body2" sx={{ fontSize: '0.75rem', fontWeight: 'bold' }}>
            {analysis.level.toUpperCase()}
          </Typography>
                )}
        </motion.div>
      </Box>
          </Box>

          {/* Risk Level Badge */}
          <Chip
            label={analysis.level.toUpperCase()}
            size="small"
            sx={{
              bgcolor: getRiskColor(analysis.level),
              color: 'white',
              fontWeight: 'bold',
              fontSize: '0.7rem',
              '& .MuiChip-label': {
                px: 1.5
              }
            }}
          />
        </CardContent>

        {/* Decorative Corner Element */}
        <Box
          sx={{
            position: 'absolute',
            top: 0,
            right: 0,
            width: 30,
            height: 30,
            background: `linear-gradient(135deg, ${getRiskColor(analysis.level)}, transparent)`,
            clipPath: 'polygon(100% 0%, 0% 100%, 100% 100%)',
            opacity: 0.3
          }}
        />
      </Card>
    </motion.div>
  );

  // Calculate average risk score
  const calculateAverageRisk = (): { score: number; level: 'low' | 'medium' | 'high' | 'critical' } => {
    const scores = Object.values(riskResults).map(r => r.score);
    const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    
    let level: 'low' | 'medium' | 'high' | 'critical';
    if (avgScore < 30) level = 'low';
    else if (avgScore < 60) level = 'medium';
    else if (avgScore < 85) level = 'high';
    else level = 'critical';
    
    return { score: avgScore, level };
  };

  // Prepare data for spider chart
  const getSpiderChartData = () => {
    return [
      {
        risk: 'Ransomware',
        value: riskResults.ransomware.score,
        level: riskResults.ransomware.level,
        fullMark: 100
      },
      {
        risk: 'Phishing',
        value: riskResults.phishing.score,
        level: riskResults.phishing.level,
        fullMark: 100
      },
      {
        risk: 'Data Breach',
        value: riskResults.dataBreach.score,
        level: riskResults.dataBreach.level,
        fullMark: 100
      },
      {
        risk: 'Insider Attack',
        value: riskResults.insiderAttack.score,
        level: riskResults.insiderAttack.level,
        fullMark: 100
      },
      {
        risk: 'Supply Chain',
        value: riskResults.supplyChain.score,
        level: riskResults.supplyChain.level,
        fullMark: 100
      }
    ];
  };

  const renderRiskIndicators = () => {
    const completionPercentage = getCompletionPercentage();
    const formComplete = isFormComplete();

    return (
      <Box sx={{ 
        display: 'flex', 
        flexDirection: 'column',
        alignItems: 'center',
        mt: 4,
        p: 3,
        backgroundColor: 'background.paper',
        borderRadius: 2,
        boxShadow: 1
      }}>
        {!formComplete ? (
          <Box sx={{ width: '100%', textAlign: 'center' }}>
            <Typography variant="h6" gutterBottom color="text.secondary">
              Complete Assessment to View Risk Analysis
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
              Please fill in all required fields to generate your cyber risk assessment
            </Typography>
            
            {/* Progress indicator */}
            <Box sx={{ width: '100%', maxWidth: 400, mx: 'auto', mb: 2 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                <Typography variant="body2" color="text.secondary">
                  Progress
                </Typography>
                <Typography variant="body2" color="primary.main" fontWeight="bold">
                  {completionPercentage}%
                </Typography>
              </Box>
              <LinearProgress 
                variant="determinate" 
                value={completionPercentage} 
                sx={{ 
                  height: 8, 
                  borderRadius: 4,
                  backgroundColor: 'grey.200',
                  '& .MuiLinearProgress-bar': {
                    borderRadius: 4,
                  }
                }} 
              />
            </Box>
            
            {/* Missing fields indicator */}
            <Box sx={{ mt: 3 }}>
              <Typography variant="caption" color="text.secondary">
                {completionPercentage < 100 ? (
                  <>
                    <InfoIcon sx={{ fontSize: 16, mr: 0.5, verticalAlign: 'middle' }} />
                    Complete all sections to unlock risk analysis
                  </>
                ) : (
                  <>
                    <CheckCircleIcon sx={{ fontSize: 16, mr: 0.5, verticalAlign: 'middle', color: 'success.main' }} />
                    All required fields completed!
                  </>
                )}
              </Typography>
            </Box>
          </Box>
        ) : (
          <>
            <Typography variant="h5" gutterBottom sx={{ mb: 4, display: 'flex', alignItems: 'center', gap: 1 }}>
              <AssessmentIcon color="primary" />
              Risk Analysis Results
            </Typography>

            {/* Average Risk Score */}
            <Box sx={{ width: '100%', maxWidth: 600, mb: 4 }}>
              <Typography variant="h6" gutterBottom align="center">
                Overall Risk Assessment
              </Typography>
              {(() => {
                const avgRisk = calculateAverageRisk();
                return (
                  <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 2 }}>
                    <Box sx={{ width: '100%', position: 'relative' }}>
                      <LinearProgress
                        variant="determinate"
                        value={avgRisk.score}
                        sx={{
                          height: 20,
                          borderRadius: 10,
                          backgroundColor: 'grey.200',
                          '& .MuiLinearProgress-bar': {
                            borderRadius: 10,
                            backgroundColor: getRiskColor(avgRisk.level),
                          }
                        }}
                      />
                      <Typography
                        variant="body2"
                        sx={{
                          position: 'absolute',
                          top: '50%',
                          left: '50%',
                          transform: 'translate(-50%, -50%)',
                          color: 'white',
                          fontWeight: 'bold',
                          textShadow: '1px 1px 2px rgba(0,0,0,0.7)'
                        }}
                      >
                        {avgRisk.level.toUpperCase()} RISK
                      </Typography>
                    </Box>
                  </Box>
                );
              })()}
            </Box>

            {/* Spider Chart and Individual Risk Levels */}
            <Box sx={{ 
              display: 'grid', 
              gridTemplateColumns: { xs: '1fr', lg: '1fr 1fr' },
              gap: 4,
              width: '100%',
              maxWidth: 1200
            }}>
              {/* Spider Chart */}
            <Box sx={{ 
              display: 'flex', 
                flexDirection: 'column', 
              alignItems: 'center',
                p: 3,
                bgcolor: 'background.paper',
                borderRadius: 2,
                boxShadow: 2
              }}>
                <Typography variant="h6" gutterBottom>
                  Risk Profile Overview
                </Typography>
                <ResponsiveContainer width="100%" height={400}>
                  <RadarChart data={getSpiderChartData()}>
                    <PolarGrid gridType="polygon" />
                    <PolarAngleAxis 
                      dataKey="risk" 
                      tick={{ fontSize: 12, fontWeight: 'bold' }}
                    />
                    <PolarRadiusAxis 
                      angle={90} 
                      domain={[0, 100]} 
                      tick={{ fontSize: 10 }}
                      tickCount={5}
                    />
                    <Radar
                      name="Risk Level"
                      dataKey="value"
                      stroke="#4f46e5"
                      fill="#4f46e5"
                      fillOpacity={0.3}
                      strokeWidth={3}
                      dot={{ fill: '#4f46e5', strokeWidth: 2, r: 6 }}
                    />
                  </RadarChart>
                </ResponsiveContainer>
              </Box>

              {/* Individual Risk Levels */}
              <Box sx={{ 
                display: 'flex', 
                flexDirection: 'column',
                gap: 2,
                p: 3,
                bgcolor: 'background.paper',
                borderRadius: 2,
                boxShadow: 2
              }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="h6" fontWeight="bold">
                    Risk Categories
                  </Typography>
                  <FormControlLabel
                    control={
                      <Switch
                        checked={showRiskNumbers}
                        onChange={(e) => setShowRiskNumbers(e.target.checked)}
                        color="primary"
                        size="small"
                      />
                    }
                    label={
                      <Typography variant="body2" color="text.secondary">
                        Show Numbers
                      </Typography>
                    }
                    sx={{ m: 0 }}
                  />
                </Box>

                {/* AI Disclaimer */}
                {showRiskNumbers && (
                  <Alert 
                    severity="info" 
                    sx={{ 
                      mb: 2,
                      '& .MuiAlert-message': { fontSize: '0.8rem' }
                    }}
                    icon={<SmartToyIcon fontSize="small" />}
                  >
                    <Typography variant="caption" sx={{ fontWeight: 'medium' }}>
                      <strong>Note:</strong> Risk levels (Low, Medium, High, Critical) provide more reliable guidance than specific percentages. 
                      Use numerical scores as relative indicators rather than absolute measurements.
                    </Typography>
                  </Alert>
                )}

                <Box sx={{ 
                  display: 'grid',
                  gridTemplateColumns: { xs: 'repeat(2, 1fr)', sm: 'repeat(3, 1fr)' },
                  gap: 2,
                  maxWidth: 600,
                  mx: 'auto'
            }}>
              {Object.entries(riskResults).map(([risk, analysis]) => (
                <RiskIndicator key={risk} risk={risk} analysis={analysis} />
              ))}
                </Box>
              </Box>
            </Box>
          </>
        )}
      </Box>
    );
  };

  const FormFieldWithTooltip = ({ 
    label, 
    tooltip, 
    children 
  }: { 
    label: string; 
    tooltip: React.ReactNode; 
    children: React.ReactNode;
  }) => (
    <Box sx={{ flex: '1 1 300px', minWidth: 0, position: 'relative' }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
        <Typography variant="subtitle2" component="span">
          {label}
        </Typography>
        <Tooltip 
          title={
            <TooltipContent>
              {tooltip}
            </TooltipContent>
          } 
          arrow 
          placement="top"
        >
          <IconButton size="small" sx={{ ml: 1 }}>
            <InfoIcon fontSize="small" />
          </IconButton>
        </Tooltip>
      </Box>
      {children}
    </Box>
  );

  const variants = {
    enter: (direction: number) => ({
      x: direction > 0 ? 500 : -500,
      opacity: 0
    }),
    center: {
      x: 0,
      opacity: 1
    },
    exit: (direction: number) => ({
      x: direction < 0 ? 500 : -500,
      opacity: 0
    })
  };

  const renderCurrentSection = () => {
    const sectionContent = [
      // Basic Info Section
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 3 }}>
        <FormFieldWithTooltip
          label="Project Duration"
          tooltip={
            <>
              <Typography variant="body2">
                The total planned duration of your project from start to completion.
              </Typography>
              <Typography variant="body2">
                This helps assess the exposure window for potential cyber threats and the complexity of maintaining security over time.
              </Typography>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.projectDuration}
              onChange={handleInputChange('projectDuration')}
            >
              <MenuItem value="<=3m">≤ 3 months</MenuItem>
              <MenuItem value="3-6m">3 - 6 months</MenuItem>
              <MenuItem value="6-12m">6 - 12 months</MenuItem>
              <MenuItem value="12-24m">12 - 24 months</MenuItem>
              <MenuItem value=">24m">{'>'}24 months</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>

        <FormFieldWithTooltip
          label="Project Type"
          tooltip={
            <>
              <Typography variant="body2">
                Project type categorizes construction projects based on characteristics, industry sectors, or focus areas.
              </Typography>
              <Typography variant="body2">
                Different project types involve varying levels of risk and cybersecurity challenges due to factors like data type, scale, critical infrastructure, and information sensitivity.
              </Typography>
              <Typography variant="body2">Categories:</Typography>
              <ul>
                <li>Transportation Infrastructure: roads, bridges, tunnels, airports, railways</li>
                <li>Government Facilities: office buildings, courthouses, police stations</li>
                <li>Healthcare Infrastructure: hospitals, clinics, medical centers</li>
                <li>Commercial Construction: shopping centers, office buildings, hotels</li>
                <li>Residential Construction: apartment buildings, housing estates</li>
              </ul>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.projectType}
              onChange={handleInputChange('projectType')}
            >
              <MenuItem value="transportation">Transportation Infrastructure Projects</MenuItem>
              <MenuItem value="government">Government Facilities Projects</MenuItem>
              <MenuItem value="healthcare">Healthcare Infrastructure Projects</MenuItem>
              <MenuItem value="commercial">Commercial Construction Projects</MenuItem>
              <MenuItem value="residential">Residential Construction Projects</MenuItem>
              <MenuItem value="other">Other types</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>

        <FormFieldWithTooltip
          label="Cybersecurity Legal Team"
          tooltip={
            <>
              <Typography variant="body2">
                A dedicated cybersecurity legal team ensures compliance, guides legal requirements, and supports incident response efforts.
              </Typography>
              <Typography variant="body2">Their responsibilities include:</Typography>
              <ul>
                <li>Contract and vendor management</li>
                <li>Risk mitigation</li>
                <li>Intellectual property protection</li>
                <li>Legal compliance oversight</li>
              </ul>
              <Typography variant="body2">
                Having such a team is crucial for compliance, data privacy, incident response, and legal protection.
              </Typography>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.hasCyberLegalTeam}
              onChange={handleInputChange('hasCyberLegalTeam')}
            >
              <MenuItem value="yes">Yes</MenuItem>
              <MenuItem value="no">No</MenuItem>
              <MenuItem value="unsure">Unsure</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>

        <FormFieldWithTooltip
          label="Company Scale"
          tooltip={
            <>
              <Typography variant="body2">
                Company scale is a critical risk factor. The total number of employees in your organization affects cybersecurity risk management capabilities, resource allocation, and the complexity of security implementation.
              </Typography>
              <Typography variant="body2">
                Understanding scale helps identify areas needing additional security controls to manage cybersecurity risks effectively.
              </Typography>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.companyScale}
              onChange={handleInputChange('companyScale')}
            >
              <MenuItem value="<=30">≤ 30</MenuItem>
              <MenuItem value="31-60">31 - 60</MenuItem>
              <MenuItem value="61-100">61 - 100</MenuItem>
              <MenuItem value="101-150">101 - 150</MenuItem>
              <MenuItem value=">150">{'>'}150</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>

        <FormFieldWithTooltip
          label="Project Phase"
          tooltip={
            <>
              <Typography variant="body2">
                Cyber risks differ by construction phase.
              </Typography>
              <Typography variant="body2">Examples of phase-specific risks:</Typography>
              <ul>
                <li>Planning/Design: Attackers stealing project information for espionage</li>
                <li>Construction: Targeting vulnerable networks or systems</li>
                <li>Each phase presents unique cybersecurity challenges and threat vectors</li>
              </ul>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.projectPhase}
              onChange={handleInputChange('projectPhase')}
            >
              <MenuItem value="planning">Planning and Bidding phase</MenuItem>
              <MenuItem value="design">Design phase</MenuItem>
              <MenuItem value="construction">Construction phase</MenuItem>
              <MenuItem value="maintenance">Maintenance & Operation phase</MenuItem>
              <MenuItem value="demolition">Demolition phase</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>
      </Box>,
      
      // Structure Section
      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
        <>
          <Alert 
            severity="info" 
            sx={{ mb: 2 }}
            iconMapping={{
              info: <></>, // Remove the default info icon
            }}
          >
            <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 1 }}>
              <IconButton 
                size="small" 
                color="info"
                onClick={() => setIsVisualDialogOpen(true)}
                sx={{ p: 0.25, mt: -0.25 }}
              >
                <InfoIcon fontSize="small" />
              </IconButton>
              <Box sx={{ flex: 1 }}>
          <Typography variant="body2">
                  <strong>Project Structure Analysis:</strong> Every construction project can be thought of as having layers, which represent different teams and their relationships:
          </Typography>
                <Box component="ul" sx={{ mt: 1, mb: 0, pl: 2 }}>
                  <li>
                    <Typography variant="body2">
                      Layer 1 (innermost): Main project teams with direct control and typically stronger cybersecurity resources
                    </Typography>
                  </li>
                  <li>
                    <Typography variant="body2">
                      Layer 2 & 3: Sub-teams or sub-contractors, often with varying levels of cybersecurity capabilities
                    </Typography>
                  </li>
                  <li>
                    <Typography variant="body2">
                      If your project doesn't have sub-teams or sub-contractors, you would only use Layer 1
                    </Typography>
                  </li>
                  <li>
                    <Typography variant="body2">
                      Click the info icon for a visual reference diagram
                    </Typography>
                  </li>
                </Box>
              </Box>
            </Box>
        </Alert>

          <Dialog
            open={isVisualDialogOpen}
            onClose={() => setIsVisualDialogOpen(false)}
            maxWidth="md"
            fullWidth
            PaperProps={{
              sx: {
                borderRadius: 2,
                boxShadow: '0 8px 32px rgba(0,0,0,0.1)',
              }
            }}
          >
            <DialogTitle sx={{ 
              pb: 1,
              display: 'flex',
              alignItems: 'center',
              gap: 1
            }}>
              <SecurityIcon color="info" />
              Project Structure Visualization
            </DialogTitle>
            <DialogContent>
              <Box sx={{ 
                display: 'flex', 
                flexDirection: 'column',
                alignItems: 'center',
                p: 2 
              }}>
                <img 
                  src={visualImage}
                  alt="Project Structure Visualization" 
                  style={{ 
                    width: '100%',
                    maxWidth: '800px',
                    height: 'auto',
                    display: 'block',
                    borderRadius: '8px',
                    boxShadow: '0 4px 12px rgba(0,0,0,0.1)'
                  }} 
                />
                <Typography variant="body2" color="text.secondary" sx={{ mt: 3, maxWidth: '600px', textAlign: 'center' }}>
                  This diagram illustrates how project teams are organized in layers. The innermost layer (Layer 1) represents main project teams, while outer layers (Layer 2 & 3) represent sub-teams and sub-contractors with varying levels of cybersecurity capabilities.
                </Typography>
              </Box>
            </DialogContent>
          </Dialog>
        </>
        
        <Box 
          sx={{ 
            display: 'grid', 
            gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
            gap: 2,
            width: '100%'
          }}
        >
          {[1, 2, 3].map((layer) => (
            <FormFieldWithTooltip
              key={layer}
              label={`Layer ${layer} Teams`}
              tooltip={
                <>
                  <Typography variant="body2">
                    Number of teams in Layer {layer}
                  </Typography>
                  <Typography variant="body2" sx={{ mt: 1, mb: 1 }}>
                    {layer === 1 ? (
                      'These are your main project teams that have direct control and typically stronger cybersecurity resources. Every project has at least one Layer 1 team.'
                    ) : layer === 2 ? (
                      'These are your first-level sub-teams or sub-contractors. Select "Not Applicable" if you don\'t have any sub-teams.'
                    ) : (
                      'These are your second-level sub-teams or sub-contractors. Select "Not Applicable" if you don\'t have this level of sub-teams.'
                    )}
                  </Typography>
                  <Typography variant="body2">Key points:</Typography>
                  <ul>
                    <li>Select the number of teams in this layer</li>
                    <li>Choose "Not Applicable" if you don't have teams in this layer</li>
                    <li>For large projects, provide your best estimate</li>
                    <li>Include both internal teams and contractors in your count</li>
                  </ul>
                </>
              }
            >
              <FormControl fullWidth size="small">
                <Select
                  value={projectInfo[`layer${layer}Teams` as keyof ProjectInfo]}
                  onChange={handleInputChange(`layer${layer}Teams` as keyof ProjectInfo)}
                >
                  <MenuItem value="<=10">≤ 10</MenuItem>
                  <MenuItem value="11-20">11 - 20</MenuItem>
                  <MenuItem value="21-30">21 - 30</MenuItem>
                  <MenuItem value="31-40">31 - 40</MenuItem>
                  <MenuItem value=">40">{'>'}40</MenuItem>
                  <MenuItem value="na">Not Applicable</MenuItem>
                </Select>
              </FormControl>
            </FormFieldWithTooltip>
          ))}
        </Box>

        <Box sx={{ mt: 2 }}>
          <FormFieldWithTooltip
            label="Team Overlap Percentage"
            tooltip={
              <>
                <Typography variant="body2">
                  The percentage of teams working on multiple projects simultaneously (overlap) increases cyber risks through shared resources, people, and potential security gaps.
                </Typography>
                <Typography variant="body2">
                  Please indicate the percentage of project teams that overlap in different projects.
                </Typography>
                <Typography variant="body2">
                  If you're unsure about teams beyond your company, please provide information for your company and subcontractors involved in the project.
                </Typography>
              </>
            }
          >
            <FormControl fullWidth size="small">
              <Select
                value={projectInfo.teamOverlap}
                onChange={handleInputChange('teamOverlap')}
              >
                <MenuItem value="<=20">≤ 20%</MenuItem>
                <MenuItem value="21-40">21% - 40%</MenuItem>
                <MenuItem value="41-60">41% - 60%</MenuItem>
                <MenuItem value="61-80">61% - 80%</MenuItem>
                <MenuItem value="81-100">81% - 100%</MenuItem>
              </Select>
            </FormControl>
          </FormFieldWithTooltip>
        </Box>
      </Box>,
      
      // Technical Section
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 3 }}>
        <Alert severity="info" sx={{ mb: 2, width: '100%' }}>
          <Typography variant="body2">
            <strong>IT Factors Focus:</strong> Please consider the selected phase of the project that you are involved in when answering the questions in this section. The questions are tailored to your selected phase rather than the overall project. Consider both your team and any subcontractors.
          </Typography>
        </Alert>

        <FormFieldWithTooltip
          label="Dedicated IT Team"
          tooltip={
            <>
              <Typography variant="body2">
                This factor evaluates the presence of a dedicated IT team specifically assigned to the project, consisting of professionals from your company and subcontractors.
              </Typography>
              <Typography variant="body2">
                The IT team members can be either from your company or from your subcontractors for the project.
              </Typography>
              <Typography variant="body2">Their involvement promotes:</Typography>
              <ul>
                <li>Effective IT management</li>
                <li>Timely response to security incidents</li>
                <li>Proactive implementation of cybersecurity measures</li>
              </ul>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.hasITTeam}
              onChange={handleInputChange('hasITTeam')}
            >
              <MenuItem value="yes">Yes</MenuItem>
              <MenuItem value="no">No</MenuItem>
              <MenuItem value="unsure">Unsure</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>

        <FormFieldWithTooltip
          label="Devices with Firewall/IDS"
          tooltip={
            <>
              <Typography variant="body2">
                The percentage of digital devices with firewalls or intrusion detection systems measures network security coverage.
              </Typography>
              <Typography variant="body2">Scope:</Typography>
              <ul>
                <li>All devices connected to project network</li>
                <li>Both company and subcontractor devices</li>
                <li>Active firewall protection</li>
                <li>Intrusion detection systems</li>
              </ul>
              <Typography variant="body2">This metric helps assess:</Typography>
              <ul>
                <li>Network security level</li>
                <li>Adherence to cybersecurity best practices</li>
                <li>Vulnerability exposure</li>
              </ul>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.devicesWithFirewall}
              onChange={handleInputChange('devicesWithFirewall')}
            >
              <MenuItem value="<=20">≤ 20%</MenuItem>
              <MenuItem value="21-40">21% - 40%</MenuItem>
              <MenuItem value="41-60">41% - 60%</MenuItem>
              <MenuItem value="61-80">61% - 80%</MenuItem>
              <MenuItem value="81-100">81% - 100%</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>

        <FormFieldWithTooltip
          label="Network Type"
          tooltip={
            <>
              <Typography variant="body2">
                The network type used for the project by your company or your subcontractors.
              </Typography>
              <Typography variant="body2">Types:</Typography>
              <ul>
                <li>Public Network: Open network (like internet), accessible to general public</li>
                <li>Private Network: Restricted network with enhanced security and control</li>
                <li>Hybrid: Combination of both networks</li>
              </ul>
              <Typography variant="body2" sx={{ mt: 1 }}>
                Note: Public networks are more accessible but potentially more vulnerable to cyber threats.
              </Typography>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.networkType}
              onChange={handleInputChange('networkType')}
            >
              <MenuItem value="public">Public network</MenuItem>
              <MenuItem value="private">Private network</MenuItem>
              <MenuItem value="both">Both public and private network</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>

        <FormFieldWithTooltip
          label="Phishing Test Failure Rate"
          tooltip={
            <>
              <Typography variant="body2">
                The percentage of individuals who fail phishing tests after completing mandatory training.
              </Typography>
              <Typography variant="body2">
                Please include all personnel from your company and subcontractors, regardless of their project involvement.
              </Typography>
              <Typography variant="body2">
                The rate measures the percentage of individuals who fail a phishing test for a second time after completing the required training.
              </Typography>
              <Typography variant="body2">
                Phishing tests are simulated attacks designed to assess individuals' susceptibility to phishing emails or other malicious tactics.
              </Typography>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.phishingFailRate}
              onChange={handleInputChange('phishingFailRate')}
            >
              <MenuItem value="<=20">≤ 20%</MenuItem>
              <MenuItem value="21-40">21% - 40%</MenuItem>
              <MenuItem value="41-60">41% - 60%</MenuItem>
              <MenuItem value="61-80">61% - 80%</MenuItem>
              <MenuItem value="81-100">81% - 100%</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>
      </Box>,
      
      // Security Section
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 3 }}>
        <FormFieldWithTooltip
          label="Governance Level"
          tooltip={
            <>
              <Typography variant="body2">
                The average level of commitment to corporate governance, ethical practices and cybersecurity policy among your team and subcontractors.
              </Typography>
              <Typography variant="body2">
                This reflects adherence to principles, transparency, accountability, ethical decision-making, and compliance. Strong commitment builds trust, protects stakeholders, and drives project success.
              </Typography>
              <Typography variant="body2">Levels:</Typography>
              <ul>
                <li>Level 1 - Low Commitment: Limited adherence, lack of transparency</li>
                <li>Level 2 - Moderate Commitment: Basic commitment, some transparency</li>
                <li>Level 3 - Average Commitment: Standard cybersecurity measures</li>
                <li>Level 4 - Above Average Commitment: Advanced cybersecurity measures</li>
                <li>Level 5 - Exemplary Commitment: State-of-the-art cybersecurity measures</li>
              </ul>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.governanceLevel}
              onChange={handleInputChange('governanceLevel')}
            >
              <MenuItem value="level1">Level 1 - Low Commitment</MenuItem>
              <MenuItem value="level2">Level 2 - Moderate Commitment</MenuItem>
              <MenuItem value="level3">Level 3 - Average Commitment</MenuItem>
              <MenuItem value="level4">Level 4 - Above Average Commitment</MenuItem>
              <MenuItem value="level5">Level 5 - Exemplary Commitment</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>

        <FormFieldWithTooltip
          label="Password Reuse Policy"
          tooltip={
            <>
              <Typography variant="body2">
                This assesses whether password reuse is allowed for project-related software, systems, or accounts.
              </Typography>
              <Typography variant="body2">Applies to:</Typography>
              <ul>
                <li>Project management tools</li>
                <li>Email systems</li>
                <li>Internal networks</li>
                <li>File storage</li>
                <li>Other project-related accounts</li>
              </ul>
              <Typography variant="body2">
                Please consider your team and your subcontractors.
              </Typography>
              <Typography variant="body2">Password reuse risks include:</Typography>
              <ul>
                <li>Increased vulnerability to credential stuffing attacks</li>
                <li>Broader system compromise if one password is breached</li>
              </ul>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.allowPasswordReuse}
              onChange={handleInputChange('allowPasswordReuse')}
            >
              <MenuItem value="yes">Yes, password reuse is allowed</MenuItem>
              <MenuItem value="no">No, password reuse is not allowed</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>

        <FormFieldWithTooltip
          label="Multi-Factor Authentication"
          tooltip={
            <>
              <Typography variant="body2">
                Does internet access within your construction project require Multi-Factor Authentication (MFA) or utilize other methods such as biometrics or face recognition?
              </Typography>
              <Typography variant="body2">
                Please consider your team and your subcontractors.
              </Typography>
              <Typography variant="body2">Benefits:</Typography>
              <ul>
                <li>Adds extra layer of security</li>
                <li>Requires multiple forms of identification</li>
                <li>Protects against unauthorized access</li>
                <li>Enhances overall cybersecurity measures</li>
              </ul>
            </>
          }
        >
          <FormControl fullWidth>
            <Select
              value={projectInfo.usesMFA}
              onChange={handleInputChange('usesMFA')}
            >
              <MenuItem value="yes">Yes, MFA/Biometrics required</MenuItem>
              <MenuItem value="no">No, MFA/Biometrics not required</MenuItem>
            </Select>
          </FormControl>
        </FormFieldWithTooltip>
      </Box>
    ];

    const arrowButtonStyle = (disabled: boolean) => ({
      bgcolor: disabled ? 'background.paper' : '#4f46e5', // New indigo color
      color: disabled ? 'text.disabled' : 'white',
      '&:hover': {
        bgcolor: disabled ? 'background.paper' : '#3c35b5', // Darker shade for hover
        boxShadow: disabled ? 2 : 4,
      },
      boxShadow: 2,
      transition: 'all 0.2s ease',
      width: 44,
      height: 44,
      border: `1px solid ${disabled ? 'rgba(0, 0, 0, 0.12)' : '#4f46e5'}`,
      '& .MuiSvgIcon-root': {
        fontSize: 24,
        ml: (direction: 'left' | 'right') => direction === 'left' ? -1 : 1
      }
    });

    return (
      <Box sx={{ position: 'relative', overflow: 'visible', mx: 3 }}>
        <Box sx={{ 
          position: 'absolute', 
          left: -20, 
          top: '50%', 
          transform: 'translateY(-50%)', 
          zIndex: 2 
        }}>
          <IconButton 
            onClick={handleBack}
            disabled={activeSection === 0}
            sx={arrowButtonStyle(activeSection === 0)}
          >
            <ArrowBackIosIcon sx={{ ml: -1 }} />
          </IconButton>
        </Box>
        
        <Box sx={{ 
          position: 'relative', 
          px: { xs: 4, sm: 6 },
          mx: 2
        }}>
          <Box sx={{ textAlign: 'center', mb: 4 }}>
            <Typography variant="h6" gutterBottom>
              {sections[activeSection]}
            </Typography>
            <Typography 
              variant="subtitle2" 
              color="text.secondary"
              sx={{ 
                maxWidth: '600px', 
                mx: 'auto',
                lineHeight: 1.4,
                fontWeight: 'normal'
              }}
            >
              {sectionDescriptions[activeSection]}
            </Typography>
          </Box>
          
          <AnimatePresence initial={false} custom={slideDirection} mode="wait">
            <motion.div
              key={activeSection}
              custom={slideDirection}
              variants={variants}
              initial="enter"
              animate="center"
              exit="exit"
              transition={{
                x: { type: "spring", stiffness: 400, damping: 25 },
                opacity: { duration: 0.15 }
              }}
              style={{
                width: '100%',
                position: 'relative',
                zIndex: 1
              }}
            >
              {sectionContent[activeSection]}
            </motion.div>
          </AnimatePresence>
        </Box>

        <Box sx={{ 
          position: 'absolute', 
          right: -20, 
          top: '50%', 
          transform: 'translateY(-50%)', 
          zIndex: 2 
        }}>
          <IconButton 
            onClick={handleNext}
            disabled={activeSection === sections.length - 1}
            sx={arrowButtonStyle(activeSection === sections.length - 1)}
          >
            <ArrowForwardIosIcon sx={{ ml: 1 }} />
          </IconButton>
        </Box>
      </Box>
    );
  };

  // Function to check if all required fields are filled
  const isFormComplete = (): boolean => {
    const requiredFields = [
      'projectDuration', 'projectType', 'hasCyberLegalTeam', 'companyScale', 'projectPhase',
      'teamOverlap', 'hasITTeam', 'devicesWithFirewall', 'networkType', 'phishingFailRate',
      'governanceLevel', 'allowPasswordReuse', 'usesMFA'
    ];
    
    // Check if all required fields have values
    const basicFieldsComplete = requiredFields.every(field => 
      projectInfo[field as keyof ProjectInfo] && projectInfo[field as keyof ProjectInfo] !== ''
    );
    
    // Check if at least one layer team is specified (not all "na")
    const hasAtLeastOneTeam = [1, 2, 3].some(layer => {
      const value = projectInfo[`layer${layer}Teams` as keyof ProjectInfo];
      return value && value !== 'na' && value !== '';
    });
    
    return basicFieldsComplete && hasAtLeastOneTeam;
  };

  // Get completion percentage for progress indicator
  const getCompletionPercentage = (): number => {
    const requiredFields = [
      'projectDuration', 'projectType', 'hasCyberLegalTeam', 'companyScale', 'projectPhase',
      'teamOverlap', 'hasITTeam', 'devicesWithFirewall', 'networkType', 'phishingFailRate',
      'governanceLevel', 'allowPasswordReuse', 'usesMFA'
    ];
    
    const filledBasicFields = requiredFields.filter(field => 
      projectInfo[field as keyof ProjectInfo] && projectInfo[field as keyof ProjectInfo] !== ''
    ).length;
    
    const hasAtLeastOneTeam = [1, 2, 3].some(layer => {
      const value = projectInfo[`layer${layer}Teams` as keyof ProjectInfo];
      return value && value !== 'na' && value !== '';
    });
    
    const totalRequired = requiredFields.length + 1; // +1 for team requirement
    const totalFilled = filledBasicFields + (hasAtLeastOneTeam ? 1 : 0);
    
    return Math.round((totalFilled / totalRequired) * 100);
  };

  // Chatbot functions
  const currentConversation = conversations.find(conv => conv.id === currentConversationId);

  // Initialize chatbot when component mounts or risk results change
  useEffect(() => {
    const initializeChat = async () => {
      console.log('🔄 Chatbot initialization triggered:', {
        hasService: !!chatbotService,
        isFormComplete: isFormComplete(),
        isChatInitialized,
        hasProjectInfo: !!projectInfo.projectType,
        hasRiskResults: Object.values(riskResults).some(r => r.score > 0),
        hasStrategy: !!riskMitigationStrategy
      });

      const isFormCompleteNow = isFormComplete();
      let service = chatbotService;

      if (!chatbotService) {
        service = new ChatbotService();
        setChatbotService(service);
      }

      if (service) {
        if (isFormCompleteNow) {
          console.log('🤖 Initializing chatbot with full data');
          const success = await service.initialize(projectInfo, riskResults, riskMitigationStrategy || undefined);
          setIsChatInitialized(success);
          
          // Update the default conversation with context-aware message
          setConversations(prev => prev.map(conv => {
            if (conv.id === 1) {
              return {
                ...conv,
                messages: [{
                  id: 1,
                  text: "Hello! I'm **Dr. CyberBuild**, your expert construction cybersecurity consultant. I have **analyzed your project data** and I'm ready to provide specialized guidance. I can see your project details, risk assessments, and mitigation strategies. What specific cybersecurity aspects would you like to discuss?",
                  sender: 'ai' as const,
                  timestamp: new Date(),
                }],
                lastUpdated: new Date(),
              };
            }
            return conv;
          }));
        } else {
          console.log('🤖 Initializing chatbot without data');
          const success = await service.initialize();
          setIsChatInitialized(success);
          
          // Update with generic message
          setConversations(prev => prev.map(conv => {
            if (conv.id === 1) {
              return {
                ...conv,
                messages: [{
                  id: 1,
                  text: "Hello! I'm **Dr. CyberBuild**, your expert construction cybersecurity consultant. I specialize in analyzing cyber risks for construction projects and providing actionable security strategies. Once you complete your risk assessment, I'll have comprehensive insights about your project to offer specialized guidance. How can I assist you today?",
                  sender: 'ai' as const,
                  timestamp: new Date(),
                }],
                lastUpdated: new Date(),
              };
            }
            return conv;
          }));
        }
      }
    };

    initializeChat();
  }, [riskResults, riskMitigationStrategy, isFormComplete()]);

  // Generate new recommended questions based on conversation history
  const updateRecommendedQuestions = async (conversationMessages: Message[]) => {
    if (!chatbotService || conversationMessages.length < 2) return;

    setIsLoadingQuestions(true);
    try {
      const conversationHistory = conversationMessages.map(msg => ({
        sender: msg.sender,
        text: msg.text
      }));

      const newQuestions = await chatbotService.generateFollowUpQuestions(conversationHistory);
      
      if (newQuestions.length > 0) {
        // Animate the question updates
        setRecommendedQuestions(newQuestions);
      }
    } catch (error) {
      console.error('Error generating follow-up questions:', error);
    } finally {
      setIsLoadingQuestions(false);
    }
  };

  // Update handleChatSend to use the chatbot service
  const handleChatSend = async () => {
    if (!chatInput.trim() || !currentConversation || !chatbotService) return;

    const userMessage: Message = {
      id: currentConversation.messages.length + 1,
      text: chatInput,
      sender: 'user',
      timestamp: new Date(),
    };

    // Update UI immediately with user message
    const updatedMessages = [...currentConversation.messages, userMessage];
    setConversations(prev => prev.map(conv => {
      if (conv.id === currentConversationId) {
        return {
          ...conv,
          messages: updatedMessages,
          lastUpdated: new Date(),
        };
      }
      return conv;
    }));

    const userInputText = chatInput;
    setChatInput('');
    
    // Show typing animation
    setIsAiTyping(true);

    try {
      // Get response from Gemini
      const aiResponseText = await chatbotService.sendMessage(userInputText);
      
      const aiMessage: Message = {
        id: currentConversation.messages.length + 2,
        text: aiResponseText,
        sender: 'ai',
        timestamp: new Date(),
      };

      const finalMessages = [...updatedMessages, aiMessage];

      // Update conversation with AI response
      setConversations(prev => prev.map(conv => {
        if (conv.id === currentConversationId) {
          return {
            ...conv,
            messages: finalMessages,
            lastUpdated: new Date(),
          };
        }
        return conv;
      }));

      // Generate new recommended questions after successful conversation
      await updateRecommendedQuestions(finalMessages);

    } catch (error) {
      console.error('Error getting chatbot response:', error);
      
      // Add error message to conversation
      const errorMessage: Message = {
        id: currentConversation.messages.length + 2,
        text: "I apologize, but I encountered an error processing your request. Please try again.",
        sender: 'ai',
        timestamp: new Date(),
      };

      setConversations(prev => prev.map(conv => {
        if (conv.id === currentConversationId) {
          return {
            ...conv,
            messages: [...updatedMessages, errorMessage],
            lastUpdated: new Date(),
          };
        }
        return conv;
      }));
    } finally {
      // Hide typing animation
      setIsAiTyping(false);
    }
  };

  // Update handleNewChat to reinitialize the chatbot
  const handleNewChat = async () => {
    if (!chatbotService) return;

    const newConversation: Conversation = {
      id: conversations.length + 1,
      title: 'Risk Analysis Chat',
      messages: [],
      lastUpdated: new Date(),
    };

    try {
      // Reinitialize the chatbot with complete project context
      if (isFormComplete()) {
        await chatbotService.initialize(projectInfo, riskResults, riskMitigationStrategy || undefined);
      } else {
        await chatbotService.initialize();
      }

      // Add initial AI message based on available data
      const hasProjectData = isFormComplete();
      const initialMessage: Message = {
        id: 1,
        text: hasProjectData 
          ? "Hello! I'm **Dr. CyberBuild**, your expert construction cybersecurity consultant. I have **analyzed your complete project data** including risk assessments and mitigation strategies. I'm ready to provide specialized guidance tailored to your specific project. What cybersecurity aspects would you like to explore?"
          : "Hello! I'm **Dr. CyberBuild**, your expert construction cybersecurity consultant. I specialize in analyzing cyber risks for construction projects. Complete your risk assessment first to get personalized insights, or ask me general cybersecurity questions. How can I help you today?",
        sender: 'ai',
        timestamp: new Date(),
      };

      newConversation.messages.push(initialMessage);
      
      setConversations([...conversations, newConversation]);
      setCurrentConversationId(newConversation.id);
    } catch (error) {
      console.error('Error creating new chat:', error);
    }
  };

  // Generate mitigation strategy with specific project info (used after applying changes)
  const generateMitigationWithUpdatedData = async (updatedProjectInfo: ProjectInfo) => {
    try {
      // Convert project info to model input array exactly matching the training data values
      const modelInput = [
        // 1.1 Project Duration (0-4 scale)
        ['<=3m', '3-6m', '6-12m', '12-24m', '>24m']
          .indexOf(updatedProjectInfo.projectDuration),

        // 1.2 Project Type (0-5 scale)
        ['transportation', 'government', 'healthcare', 'commercial', 'residential', 'other']
          .indexOf(updatedProjectInfo.projectType),

        // 1.3 Has Cyber Legal Team (0-2 scale)
        ['yes', 'no', 'unsure'].indexOf(updatedProjectInfo.hasCyberLegalTeam),

        // 1.4 Company Scale (0-4 scale)
        ['<=30', '31-60', '61-100', '101-150', '>150']
          .indexOf(updatedProjectInfo.companyScale),

        // 1.5 Project Phase (0-4 scale)
        ['planning', 'design', 'construction', 'maintenance', 'demolition']
          .indexOf(updatedProjectInfo.projectPhase),

        // 2.1.1 Layer 1 Teams (0-5 scale)
        ['<=10', '11-20', '21-30', '31-40', '>40', 'na']
          .indexOf(updatedProjectInfo.layer1Teams),

        // 2.1.2 Layer 2 Teams (0-5 scale)
        ['<=10', '11-20', '21-30', '31-40', '>40', 'na']
          .indexOf(updatedProjectInfo.layer2Teams),

        // 2.1.3 Layer 3 Teams (0-5 scale)
        ['<=10', '11-20', '21-30', '31-40', '>40', 'na']
          .indexOf(updatedProjectInfo.layer3Teams),

        // 2.2 Team Overlap (0-4 scale)
        ['<=20', '21-40', '41-60', '61-80', '81-100']
          .indexOf(updatedProjectInfo.teamOverlap),

        // 3.1 Has IT Team (0-2 scale)
        ['yes', 'no', 'unsure'].indexOf(updatedProjectInfo.hasITTeam),

        // 3.2 Devices with Firewall (0-4 scale)
        ['<=20', '21-40', '41-60', '61-80', '81-100']
          .indexOf(updatedProjectInfo.devicesWithFirewall),

        // 3.3 Network Type (0-2 scale)
        ['public', 'private', 'both'].indexOf(updatedProjectInfo.networkType),

        // 3.4 Phishing Fail Rate (0-4 scale)
        ['<=20', '21-40', '41-60', '61-80', '81-100']
          .indexOf(updatedProjectInfo.phishingFailRate),

        // 4.1 Governance Level (0-4 scale)
        ['level1', 'level2', 'level3', 'level4', 'level5']
          .indexOf(updatedProjectInfo.governanceLevel),

        // 4.2 Allow Password Reuse (0-1 scale)
        ['yes', 'no'].indexOf(updatedProjectInfo.allowPasswordReuse),

        // 4.3 Uses MFA (0-1 scale)
        ['yes', 'no'].indexOf(updatedProjectInfo.usesMFA)
      ];

      // Call the mitigation strategy API
      const response = await fetch('http://localhost:8000/mitigation-strategy', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ user_data: modelInput }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('Mitigation API Error:', errorData);
        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
      }

      const strategy = await response.json();
      console.log('🔄 Mitigation Strategy Response (Updated Data):', strategy);
      console.log('🔄 Updated form data sent to API:', modelInput);
      
      // Convert API response to our interface format
      const convertedStrategy: RiskMitigationStrategy = {
        initialRisk: strategy.initialRisk,
        finalRisk: strategy.finalRisk,
        totalReduction: strategy.totalReduction,
        totalReductionPercentage: strategy.totalReductionPercentage,
        implementationPriority: strategy.implementationPriority,
        rounds: strategy.rounds.map((round: any) => ({
          roundNumber: round.roundNumber,
          features: round.features,
          currentRisk: round.currentRisk,
          projectedRisk: round.projectedRisk,
          riskReduction: round.riskReduction,
          reductionPercentage: round.reductionPercentage,
          recommendations: round.recommendations.map((rec: any) => ({
            featureGroup: rec.featureGroup,
            featureName: rec.featureName,
            currentOption: rec.currentOption,
            recommendedOption: rec.recommendedOption,
            optionIndex: rec.optionIndex,
            description: rec.description
          }))
        }))
      };

      console.log('🔄 Setting updated strategy:', {
        oldInitialRisk: riskMitigationStrategy?.initialRisk,
        newInitialRisk: convertedStrategy.initialRisk,
        oldTotalReduction: riskMitigationStrategy?.totalReductionPercentage,
        newTotalReduction: convertedStrategy.totalReductionPercentage
      });
      
      setRiskMitigationStrategy(convertedStrategy);
      
      // Load ALL enhanced descriptions in one API call (but only if not already cached)
      loadAllEnhancedDescriptions(convertedStrategy);
      
      // Update chatbot context with new strategy
      if (chatbotService && isChatInitialized) {
        try {
          await chatbotService.updateContext(updatedProjectInfo, undefined, convertedStrategy);
        } catch (error) {
          console.error('Failed to update chatbot context:', error);
        }
      }
      
      // Preserve the current round - no round changes during silent updates
       
     } catch (error) {
       console.error('Risk mitigation analysis failed:', error);
       throw error;
     }
   };

  // Risk mitigation analysis
  const analyzeRiskMitigation = async () => {
    if (!isFormComplete()) return;

    setIsAnalyzingReductions(true);
    
    try {
      // Convert project info to model input array exactly matching the training data values
      const modelInput = [
        // 1.1 Project Duration (0-4 scale)
        ['<=3m', '3-6m', '6-12m', '12-24m', '>24m']
          .indexOf(projectInfo.projectDuration),

        // 1.2 Project Type (0-5 scale)
        ['transportation', 'government', 'healthcare', 'commercial', 'residential', 'other']
          .indexOf(projectInfo.projectType),

        // 1.3 Has Cyber Legal Team (0-2 scale)
        ['yes', 'no', 'unsure'].indexOf(projectInfo.hasCyberLegalTeam),

        // 1.4 Company Scale (0-4 scale)
        ['<=30', '31-60', '61-100', '101-150', '>150']
          .indexOf(projectInfo.companyScale),

        // 1.5 Project Phase (0-4 scale)
        ['planning', 'design', 'construction', 'maintenance', 'demolition']
          .indexOf(projectInfo.projectPhase),

        // 2.1.1 Layer 1 Teams (0-5 scale)
        ['<=10', '11-20', '21-30', '31-40', '>40', 'na']
          .indexOf(projectInfo.layer1Teams),

        // 2.1.2 Layer 2 Teams (0-5 scale)
        ['<=10', '11-20', '21-30', '31-40', '>40', 'na']
          .indexOf(projectInfo.layer2Teams),

        // 2.1.3 Layer 3 Teams (0-5 scale)
        ['<=10', '11-20', '21-30', '31-40', '>40', 'na']
          .indexOf(projectInfo.layer3Teams),

        // 2.2 Team Overlap (0-4 scale)
        ['<=20', '21-40', '41-60', '61-80', '81-100']
          .indexOf(projectInfo.teamOverlap),

        // 3.1 Has IT Team (0-2 scale)
        ['yes', 'no', 'unsure'].indexOf(projectInfo.hasITTeam),

        // 3.2 Devices with Firewall (0-4 scale)
        ['<=20', '21-40', '41-60', '61-80', '81-100']
          .indexOf(projectInfo.devicesWithFirewall),

        // 3.3 Network Type (0-2 scale)
        ['public', 'private', 'both'].indexOf(projectInfo.networkType),

        // 3.4 Phishing Fail Rate (0-4 scale)
        ['<=20', '21-40', '41-60', '61-80', '81-100']
          .indexOf(projectInfo.phishingFailRate),

        // 4.1 Governance Level (0-4 scale)
        ['level1', 'level2', 'level3', 'level4', 'level5']
          .indexOf(projectInfo.governanceLevel),

        // 4.2 Allow Password Reuse (0-1 scale)
        ['yes', 'no'].indexOf(projectInfo.allowPasswordReuse),

        // 4.3 Uses MFA (0-1 scale)
        ['yes', 'no'].indexOf(projectInfo.usesMFA)
      ];

      // Call the mitigation strategy API
      const response = await fetch('http://localhost:8000/mitigation-strategy', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ user_data: modelInput }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('Mitigation API Error:', errorData);
        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
      }

      const strategy = await response.json();
      console.log('📊 Initial Mitigation Strategy Response:', strategy);
      console.log('📊 Form data sent to API:', modelInput);
      
             // Convert API response to our interface format
       const convertedStrategy: RiskMitigationStrategy = {
        initialRisk: strategy.initialRisk,
        finalRisk: strategy.finalRisk,
        totalReduction: strategy.totalReduction,
        totalReductionPercentage: strategy.totalReductionPercentage,
        implementationPriority: strategy.implementationPriority,
        rounds: strategy.rounds.map((round: any) => ({
          roundNumber: round.roundNumber,
          features: round.features,
          currentRisk: round.currentRisk,
          projectedRisk: round.projectedRisk,
          riskReduction: round.riskReduction,
          reductionPercentage: round.reductionPercentage,
          recommendations: round.recommendations.map((rec: any) => ({
            featureGroup: rec.featureGroup,
            featureName: rec.featureName,
            currentOption: rec.currentOption,
            recommendedOption: rec.recommendedOption,
            optionIndex: rec.optionIndex,
            description: rec.description
          }))
        }))
      };

      setRiskMitigationStrategy(convertedStrategy);
      
      // Load ALL enhanced descriptions in one API call
      loadAllEnhancedDescriptions(convertedStrategy);
      
      // Reset applied recommendations when manually refreshing
      setAppliedRecommendations(new Set());
      
      // Reset to overview when refreshing manually
      setSelectedRound(0);
      
    } catch (error) {
      console.error('Risk mitigation analysis failed:', error);
    } finally {
      setIsAnalyzingReductions(false);
    }
  };

  // Toggle recommendation (apply or unapply)
  const toggleRecommendation = async (recommendation: RiskMitigationRecommendation) => {
    const recommendationId = `${recommendation.featureGroup}-${recommendation.recommendedOption}`;
    const persistentId = `${recommendation.featureGroup}-${recommendation.currentOption}-to-${recommendation.recommendedOption}`;
    
    // Check if already applied
    const isCurrentlyApplied = appliedRecommendations.has(recommendationId) || appliedRecommendations.has(persistentId);
    
    if (isCurrentlyApplied) {
      // Unapply: revert to original current option
      await unapplyRecommendation(recommendation);
    } else {
      // Apply: change to recommended option
      await applyRecommendation(recommendation);
    }
  };

  // Unapply recommendation (revert to original value)
  const unapplyRecommendation = async (recommendation: RiskMitigationRecommendation) => {
    const recommendationId = `${recommendation.featureGroup}-${recommendation.recommendedOption}`;
    const persistentId = `${recommendation.featureGroup}-${recommendation.currentOption}-to-${recommendation.recommendedOption}`;
    
    setApplyingRecommendation(recommendationId);
    
    try {
      // Map feature groups to form fields
      const fieldMapping: { [key: string]: keyof ProjectInfo } = {
        '1.3': 'hasCyberLegalTeam',
        '2.1.1': 'layer1Teams',
        '2.1.2': 'layer2Teams', 
        '2.1.3': 'layer3Teams',
        '2.2': 'teamOverlap',
        '3.1': 'hasITTeam',
        '3.2': 'devicesWithFirewall',
        '3.3': 'networkType',
        '3.4': 'phishingFailRate',
        '4.1': 'governanceLevel',
        '4.2': 'allowPasswordReuse',
        '4.3': 'usesMFA'
      };

      const fieldKey = fieldMapping[recommendation.featureGroup];
      if (!fieldKey) {
        console.warn(`No field mapping found for feature group: ${recommendation.featureGroup}`);
        return;
      }

      // Get the original form value (from current option)
      const getFormValue = (featureGroup: string, currentOption: string): string => {
        switch (featureGroup) {
          case '1.3': // Cybersecurity Legal Team
            return currentOption === 'Yes' ? 'yes' : 'no';
          case '2.1.1': // Layer 1 Teams
          case '2.1.2': // Layer 2 Teams  
          case '2.1.3': // Layer 3 Teams
            if (currentOption === '>40') return '>40';
            if (currentOption === '31-40') return '31-40';
            if (currentOption === '21-30') return '21-30';
            if (currentOption === '11-20') return '11-20';
            if (currentOption === '≤10') return '<=10';
            return 'na';
          case '2.2': // Team Overlap
            if (currentOption === '≤20%') return '<=20';
            if (currentOption === '21-40%') return '21-40';
            if (currentOption === '41-60%') return '41-60';
            if (currentOption === '61-80%') return '61-80';
            return '81-100';
          case '3.1': // IT Team
            return currentOption === 'Yes' ? 'yes' : currentOption === 'No' ? 'no' : 'unsure';
          case '3.2': // Firewall Coverage
            if (currentOption === '81-100%') return '81-100';
            if (currentOption === '61-80%') return '61-80';
            if (currentOption === '41-60%') return '41-60';
            if (currentOption === '21-40%') return '21-40';
            return '<=20';
          case '3.3': // Network Type
            if (currentOption === 'Private network') return 'private';
            if (currentOption === 'Public network') return 'public';
            return 'both';
          case '3.4': // Phishing Failure Rate
            if (currentOption === '≤20%') return '<=20';
            if (currentOption === '21-40%') return '21-40';
            if (currentOption === '41-60%') return '41-60';
            if (currentOption === '61-80%') return '61-80';
            return '81-100';
          case '4.1': // Governance Level
            if (currentOption === 'Level 5') return 'level5';
            if (currentOption === 'Level 4') return 'level4';
            if (currentOption === 'Level 3') return 'level3';
            if (currentOption === 'Level 2') return 'level2';
            return 'level1';
          case '4.2': // Password Reuse
            return currentOption === 'Not Allowed' ? 'no' : 'yes';
          case '4.3': // MFA
            return currentOption === 'Yes' ? 'yes' : 'no';
          default:
            return '';
        }
      };

      const originalValue = getFormValue(recommendation.featureGroup, recommendation.currentOption);
      
      // Update the form back to original value
      const updatedProjectInfo = {
        ...projectInfo,
        [fieldKey]: originalValue
      };
      
      setProjectInfo(updatedProjectInfo);

      // Recalculate risk analysis with reverted data
      setIsLoading(true);
      setApiError(null);
      
      try {
        if (useRandomResults) {
          const results = generateRandomResults();
          setRiskResults(results);
        } else {
          const results = await riskApiService.calculateRisk(updatedProjectInfo);
          setRiskResults(results);
        }
        
        // Delay the strategy refresh
        setTimeout(async () => {
          const currentRound = selectedRound;
          setPreservedRound(currentRound);
          setIsUpdatingStrategy(true);
          
          try {
            if (!useRandomResults) {
              const freshRiskResults = await riskApiService.calculateRisk(updatedProjectInfo);
              setRiskResults(freshRiskResults);
            }
            
            await generateMitigationWithUpdatedData(updatedProjectInfo);
            setSelectedRound(currentRound);
            setIsUpdatingStrategy(false);
          } catch (error) {
            console.error('Strategy update failed:', error);
            setSelectedRound(currentRound);
            setIsUpdatingStrategy(false);
          }
        }, 1500);
        
        // Remove recommendation from applied set
        setAppliedRecommendations(prev => {
          const newSet = new Set(prev);
          newSet.delete(recommendationId);
          newSet.delete(persistentId);
          return newSet;
        });
        
        console.log(`Unapplied recommendation: ${recommendation.featureName} → reverted to ${recommendation.currentOption}`);
      } catch (error) {
        console.error('Risk recalculation failed:', error);
        setApiError((error as Error).message || 'Failed to recalculate risk scores');
      } finally {
        setIsLoading(false);
        setApplyingRecommendation(null);
      }
    } catch (error) {
      console.error('Error unapplying recommendation:', error);
      setApplyingRecommendation(null);
    }
  };

  // Apply recommendation to form
  const applyRecommendation = async (recommendation: RiskMitigationRecommendation) => {
    const recommendationId = `${recommendation.featureGroup}-${recommendation.recommendedOption}`;
    setApplyingRecommendation(recommendationId);
    
    try {
      // Map feature groups to form fields
      const fieldMapping: { [key: string]: keyof ProjectInfo } = {
      '1.3': 'hasCyberLegalTeam',
      '2.1.1': 'layer1Teams',
      '2.1.2': 'layer2Teams', 
      '2.1.3': 'layer3Teams',
      '2.2': 'teamOverlap',
      '3.1': 'hasITTeam',
      '3.2': 'devicesWithFirewall',
      '3.3': 'networkType',
      '3.4': 'phishingFailRate',
      '4.1': 'governanceLevel',
      '4.2': 'allowPasswordReuse',
      '4.3': 'usesMFA'
    };

    const fieldKey = fieldMapping[recommendation.featureGroup];
    if (!fieldKey) {
      console.warn(`No field mapping found for feature group: ${recommendation.featureGroup}`);
      return;
    }

    // Map recommended options to form values
    const getFormValue = (featureGroup: string, recommendedOption: string): string => {
      switch (featureGroup) {
        case '1.3': // Cybersecurity Legal Team
          return recommendedOption === 'Yes' ? 'yes' : 'no';
        case '2.1.1': // Layer 1 Teams
        case '2.1.2': // Layer 2 Teams  
        case '2.1.3': // Layer 3 Teams
          if (recommendedOption === '>40') return '>40';
          if (recommendedOption === '31-40') return '31-40';
          if (recommendedOption === '21-30') return '21-30';
          if (recommendedOption === '11-20') return '11-20';
          if (recommendedOption === '≤10') return '<=10';
          return 'na';
        case '2.2': // Team Overlap
          if (recommendedOption === '≤20%') return '<=20';
          if (recommendedOption === '21-40%') return '21-40';
          if (recommendedOption === '41-60%') return '41-60';
          if (recommendedOption === '61-80%') return '61-80';
          return '81-100';
        case '3.1': // IT Team
          return recommendedOption === 'Yes' ? 'yes' : recommendedOption === 'No' ? 'no' : 'unsure';
        case '3.2': // Firewall Coverage
          if (recommendedOption === '81-100%') return '81-100';
          if (recommendedOption === '61-80%') return '61-80';
          if (recommendedOption === '41-60%') return '41-60';
          if (recommendedOption === '21-40%') return '21-40';
          return '<=20';
        case '3.3': // Network Type
          if (recommendedOption === 'Private network') return 'private';
          if (recommendedOption === 'Public network') return 'public';
          return 'both';
        case '3.4': // Phishing Failure Rate
          if (recommendedOption === '≤20%') return '<=20';
          if (recommendedOption === '21-40%') return '21-40';
          if (recommendedOption === '41-60%') return '41-60';
          if (recommendedOption === '61-80%') return '61-80';
          return '81-100';
        case '4.1': // Governance Level
          if (recommendedOption === 'Level 5') return 'level5';
          if (recommendedOption === 'Level 4') return 'level4';
          if (recommendedOption === 'Level 3') return 'level3';
          if (recommendedOption === 'Level 2') return 'level2';
          return 'level1';
        case '4.2': // Password Reuse
          return recommendedOption === 'Not Allowed' ? 'no' : 'yes';
        case '4.3': // MFA
          return recommendedOption === 'Yes' ? 'yes' : 'no';
        default:
          return '';
      }
    };

    const newValue = getFormValue(recommendation.featureGroup, recommendation.recommendedOption);
    
        // Update the form
    const updatedProjectInfo = {
      ...projectInfo,
      [fieldKey]: newValue
    };
    
    setProjectInfo(updatedProjectInfo);

    // Recalculate risk analysis with updated data
    setIsLoading(true);
    setApiError(null);
    
    try {
      if (useRandomResults) {
        const results = generateRandomResults();
        setRiskResults(results);
      } else {
        const results = await riskApiService.calculateRisk(updatedProjectInfo);
        setRiskResults(results);
      }
      
      // Delay the strategy refresh to allow for smooth UI transitions
      setTimeout(async () => {
        const currentRound = selectedRound; // Capture current round before update
        setPreservedRound(currentRound); // Store it separately
        setIsUpdatingStrategy(true);
        
        try {
          console.log('🔧 Refreshing strategy with updated data...', updatedProjectInfo);
          
          // Also recalculate the base risk results to ensure everything is in sync
          if (!useRandomResults) {
            const freshRiskResults = await riskApiService.calculateRisk(updatedProjectInfo);
            setRiskResults(freshRiskResults);
            console.log('🔧 Updated risk results:', freshRiskResults);
          }
          
          // Generate new strategy with the updated form data
          await generateMitigationWithUpdatedData(updatedProjectInfo);
          // Restore the round immediately and consistently
          setSelectedRound(currentRound);
          setIsUpdatingStrategy(false);
        } catch (error) {
          console.error('Strategy update failed:', error);
          setSelectedRound(currentRound); // Restore even on error
          setIsUpdatingStrategy(false);
        }
      }, 1500); // Longer delay to let the user see the "Applied" state
      
      // Mark recommendation as applied with more specific tracking
      const persistentId = `${recommendation.featureGroup}-${recommendation.currentOption}-to-${recommendation.recommendedOption}`;
      setAppliedRecommendations(prev => new Set([...prev, recommendationId, persistentId]));
      
      console.log(`Applied recommendation: ${recommendation.featureName} → ${recommendation.recommendedOption}`);
    } catch (error) {
      console.error('Risk recalculation failed:', error);
      setApiError((error as Error).message || 'Failed to recalculate risk scores');
    } finally {
      setIsLoading(false);
      setApplyingRecommendation(null);
    }
  } catch (error) {
    console.error('Error applying recommendation:', error);
    setApplyingRecommendation(null);
  }
  };

  // Handle changeable property toggle
  const toggleChangeableProperty = (key: string) => {
    setChangeableProperties(prev => 
      prev.map(prop => 
        prop.key === key ? { ...prop, changeable: !prop.changeable } : prop
      )
    );
    // Re-analyze if we have existing results
    if (riskReductions.length > 0) {
      analyzeRiskMitigation();
    }
  };

  // Toggle recommendation lock
  const toggleRecommendationLock = (recommendationId: string) => {
    setLockedRecommendations(prev => {
      const newSet = new Set(prev);
      if (newSet.has(recommendationId)) {
        newSet.delete(recommendationId);
      } else {
        newSet.add(recommendationId);
      }
      return newSet;
    });
  };

  // Fetch enhanced descriptions for ALL recommendations in the entire strategy (one-time call)
  const fetchAllEnhancedDescriptions = async (allRecommendations: RiskMitigationRecommendation[]): Promise<RiskMitigationRecommendation[]> => {
    try {
      // Create a batch prompt for all recommendations
      const batchPrompt = `Analyze these cybersecurity recommendations for a construction project. For each recommendation, provide a brief analysis including cost and importance.

${allRecommendations.map((rec, index) => `
**Recommendation ${index + 1}:**
Feature: ${rec.featureName}
Current: ${rec.currentOption}
Recommended: ${rec.recommendedOption}
Description: ${rec.description}
`).join('')}

For each recommendation, provide analysis in this exact format:
Recommendation [number]: Cost: [$ signs]. Importance: [level]. [Brief explanation]

Use:
- Cost: $ (low), $$ (moderate), $$$ (high), $$$$ (very high)
- Importance: Critical/High/Medium/Low
- Keep explanations to 1-2 sentences maximum

Provide all ${allRecommendations.length} analyses:`;

      const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=' + import.meta.env.VITE_GEMINI_API_KEY, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: batchPrompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error('Failed to fetch from Gemini API');
      }

      const data = await response.json();
      const batchResponse = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
      
      // Parse the batch response to extract individual recommendations
      const enhancedRecommendations = allRecommendations.map((rec, index) => {
        try {
          // Look for the specific recommendation number
          const recommendationPattern = new RegExp(`Recommendation ${index + 1}:\\s*Cost:\\s*(\\$+)\\.\\s*Importance:\\s*(\\w+)\\.\\s*([^\\n]*(?:\\n[^R]*?)*)`, 'i');
          const match = batchResponse.match(recommendationPattern);
          
          if (match) {
            const [, costSignsMatch, importance, description] = match;
            const costLevel = costSignsMatch ? costSignsMatch.length : 2;
            const cleanDescription = description.trim().replace(/Recommendation \d+:/gi, '').trim();
            
            return {
              ...rec,
              enhancedDescription: cleanDescription.length > 10 ? cleanDescription : rec.description,
              costLevel: Math.min(Math.max(costLevel, 1), 4),
              importance: importance || 'Medium'
            };
          } else {
            // Fallback parsing if numbered format fails
            const lines = batchResponse.split('\n').filter((line: string) => line.trim());
            const relevantLine = lines[index] || '';
            
            const costMatch = relevantLine.match(/Cost:\s*(\$+)/);
            const importanceMatch = relevantLine.match(/Importance:\s*(\w+)/);
            const costLevel = costMatch ? costMatch[1].length : 2;
            const importance = importanceMatch ? importanceMatch[1] : 'Medium';
            
            // Extract description by removing the structured part
            let cleanDescription = relevantLine.replace(/^.*?Cost:\s*\$+\.\s*Importance:\s*\w+\.\s*/, '').trim();
            if (cleanDescription.length < 10) {
              cleanDescription = rec.description;
            }
            
            return {
              ...rec,
              enhancedDescription: cleanDescription,
              costLevel: Math.min(Math.max(costLevel, 1), 4),
              importance
            };
          }
        } catch (parseError) {
          console.error(`Error parsing recommendation ${index + 1}:`, parseError);
          return {
            ...rec,
            enhancedDescription: rec.description,
            costLevel: 2,
            importance: 'Medium'
          };
        }
      });

      return enhancedRecommendations;
    } catch (error) {
      console.error('Error fetching all enhanced descriptions:', error);
      // Return original recommendations with defaults
      return allRecommendations.map(rec => ({
        ...rec,
        enhancedDescription: rec.description,
        costLevel: 2,
        importance: 'Medium'
      }));
    }
  };

  // Load ALL enhanced descriptions once for the entire strategy
  const loadAllEnhancedDescriptions = async (strategy: RiskMitigationStrategy): Promise<void> => {
    // Collect all recommendations from all rounds
    const allRecommendations = strategy.rounds.flatMap(round => round.recommendations);
    
    // Check if any are missing from cache
    const uncachedRecommendations = allRecommendations.filter(rec => {
      const cacheKey = `${rec.featureGroup}-${rec.featureName}-${rec.description}`;
      return !enhancedDescriptions.has(cacheKey);
    });
    
    // If all are cached, no need to make API call
    if (uncachedRecommendations.length === 0) {
      return;
    }
    
    try {
      // Make ONE API call for all recommendations
      const enhanced = await fetchAllEnhancedDescriptions(allRecommendations);
      
      // Cache all enhanced recommendations
      enhanced.forEach(enhancedRec => {
        const cacheKey = `${enhancedRec.featureGroup}-${enhancedRec.featureName}-${enhancedRec.description}`;
        setEnhancedDescriptions(prev => new Map(prev.set(cacheKey, enhancedRec)));
      });
    } catch (error) {
      console.error('Error loading all enhanced descriptions:', error);
      // Cache original recommendations as fallback
      allRecommendations.forEach(rec => {
        const cacheKey = `${rec.featureGroup}-${rec.featureName}-${rec.description}`;
        setEnhancedDescriptions(prev => new Map(prev.set(cacheKey, {
          ...rec,
          enhancedDescription: rec.description,
          costLevel: 2,
          importance: 'Medium'
        })));
      });
    }
  };

  // Get enhanced recommendations from cache (no API calls)
  const getEnhancedRecommendations = (recommendations: RiskMitigationRecommendation[]): RiskMitigationRecommendation[] => {
    return recommendations.map(rec => {
      const cacheKey = `${rec.featureGroup}-${rec.featureName}-${rec.description}`;
      return enhancedDescriptions.get(cacheKey) || rec;
    });
  };

  // Single recommendation wrapper for backward compatibility
  const getEnhancedRecommendation = async (recommendation: RiskMitigationRecommendation): Promise<RiskMitigationRecommendation> => {
    const results = await getEnhancedRecommendations([recommendation]);
    return results[0];
  };

  // Batch Recommendations Loader Component
  const BatchRecommendationsLoader = ({ 
    round 
  }: { 
    round: RiskMitigationRound;
  }) => {
    const [enhancedRecommendations, setEnhancedRecommendations] = useState<RiskMitigationRecommendation[]>([]);
    const [isLoadingBatch, setIsLoadingBatch] = useState(true);

    useEffect(() => {
      // Check if recommendations are already in cache
      const allCached = round.recommendations.every(rec => {
        const cacheKey = `${rec.featureGroup}-${rec.featureName}-${rec.description}`;
        return enhancedDescriptions.has(cacheKey);
      });
      
      if (allCached) {
        // Get from cache immediately - no loading needed
        const cached = getEnhancedRecommendations(round.recommendations);
        setEnhancedRecommendations(cached);
        setIsLoadingBatch(false);
      } else {
        // Only set loading to true if we don't have any recommendations yet
        // This prevents infinite loading when cache is being populated
        if (enhancedRecommendations.length === 0) {
          setIsLoadingBatch(true);
          setEnhancedRecommendations([]);
        }
      }
    }, [round.roundNumber, round.recommendations.length, enhancedDescriptions.size]);

    return (
      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
        {isLoadingBatch && enhancedRecommendations.length === 0 ? (
          // Show loading skeletons while first batch is loading
          <>
            {round.recommendations.map((_, index) => (
              <Card 
                key={`skeleton-${index}`}
                variant="outlined" 
                sx={{ 
                  height: 200,
                  position: 'relative',
                  overflow: 'hidden'
                }}
              >
                <CardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                    <Skeleton variant="text" width="60%" height={28} />
                    <Skeleton variant="circular" width={24} height={24} />
                  </Box>
                  
                  <Skeleton variant="text" width="100%" height={20} sx={{ mb: 1 }} />
                  <Skeleton variant="text" width="80%" height={20} sx={{ mb: 2 }} />
                  
                  <Box sx={{ display: 'flex', gap: 1, mb: 2 }}>
                    <Skeleton variant="rounded" width={40} height={24} />
                    <Skeleton variant="rounded" width={60} height={24} />
                  </Box>
                  
                  <Skeleton variant="text" width="90%" height={16} sx={{ mb: 1 }} />
                  <Skeleton variant="text" width="70%" height={16} sx={{ mb: 2 }} />
                  
                  <Box sx={{ display: 'flex', gap: 1 }}>
                    <Skeleton variant="rounded" width={120} height={32} />
                    <Skeleton variant="rounded" width={140} height={32} />
                  </Box>
                </CardContent>
                
                {/* Subtle shimmer effect */}
                <Box
                  sx={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: 'linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent)',
                    transform: 'translateX(-100%)',
                    animation: 'shimmer 1.5s infinite',
                    '@keyframes shimmer': {
                      '0%': { transform: 'translateX(-100%)' },
                      '100%': { transform: 'translateX(100%)' }
                    }
                  }}
                />
              </Card>
            ))}
          </>
        ) : (
          // Show actual recommendations
          enhancedRecommendations.map((rec, index) => (
            <motion.div
              key={`${rec.featureGroup}-${rec.featureName}-${index}`}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ 
                duration: 0.3,
                delay: index * 0.1
              }}
            >
              <SimpleRecommendationCard 
                rec={rec} 
                index={index} 
              />
            </motion.div>
          ))
        )}
      </Box>
    );
  };

  // Simple Recommendation Card Component (for batch loading)
  const SimpleRecommendationCard = ({ 
    rec, 
    index 
  }: { 
    rec: RiskMitigationRecommendation; 
    index: number; 
  }) => {
    const recommendationId = `${rec.featureGroup}-${rec.recommendedOption}`;
    const persistentId = `${rec.featureGroup}-${rec.currentOption}-to-${rec.recommendedOption}`;
    const lockId = `${rec.featureGroup}-${rec.featureName}`;
    
    const isApplied = appliedRecommendations.has(recommendationId) || appliedRecommendations.has(persistentId);
    const isLocked = lockedRecommendations.has(lockId);
    const isAlreadySet = rec.currentOption === rec.recommendedOption;
    const isApplying = applyingRecommendation === recommendationId;

    const getCostDisplay = (costLevel?: number) => {
      if (!costLevel) return '$$';
      return '$'.repeat(Math.min(Math.max(costLevel, 1), 4));
    };

    const getCostColor = (costLevel?: number) => {
      if (!costLevel) return '#ff9800';
      switch (costLevel) {
        case 1: return '#4caf50';
        case 2: return '#ff9800';
        case 3: return '#f44336';
        case 4: return '#d32f2f';
        default: return '#ff9800';
      }
    };

    const getCostLabel = (costLevel?: number) => {
      if (!costLevel) return 'Medium Cost';
      switch (costLevel) {
        case 1: return 'Low Cost';
        case 2: return 'Medium Cost';
        case 3: return 'High Cost';
        case 4: return 'Very High Cost';
        default: return 'Medium Cost';
      }
    };

    const getCostDescription = (costLevel?: number) => {
      if (!costLevel) return 'Moderate investment required for implementation';
      switch (costLevel) {
        case 1: return 'Minimal investment required - quick and easy to implement';
        case 2: return 'Moderate investment required - reasonable cost with good ROI';
        case 3: return 'Significant investment required - higher cost but important for security';
        case 4: return 'Major investment required - substantial cost but critical for comprehensive security';
        default: return 'Moderate investment required for implementation';
      }
    };

    const getImportanceColor = (importance?: string) => {
      switch (importance?.toLowerCase()) {
        case 'critical': return '#d32f2f';
        case 'high': return '#f44336';
        case 'medium': return '#ff9800';
        case 'low': return '#4caf50';
        default: return '#ff9800';
      }
    };

    return (
      <motion.div
        key={index}
        layout
        initial={{ opacity: 0, y: 20 }}
        animate={{ 
          opacity: 1, 
          y: 0,
          scale: isApplied ? [1, 1.02, 1] : 1,
        }}
        transition={{ 
          duration: 0.3,
          delay: index * 0.1,
          scale: { duration: 0.5, times: [0, 0.5, 1] }
        }}
      >
        <Card 
          variant="outlined" 
          sx={{
            position: 'relative',
            overflow: 'hidden',
            opacity: isLocked ? 0.7 : 1,
            ...(isApplied && {
              bgcolor: (theme) => theme.palette.mode === 'dark' 
                        ? 'rgba(76, 175, 80, 0.15)' 
                        : 'success.light',
              borderColor: 'success.main',
              boxShadow: (theme) => theme.palette.mode === 'dark'
                ? '0 0 20px rgba(76, 175, 80, 0.4)'
                : '0 0 20px rgba(76, 175, 80, 0.3)',
              color: (theme) => theme.palette.mode === 'dark' 
                ? 'success.light' 
                : 'inherit',
            }),
            ...(isLocked && {
              borderColor: 'grey.400',
              bgcolor: 'grey.50',
            })
          }}
        >
          {isApplied && (
            <Box
              sx={{
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                height: 4,
                bgcolor: 'success.main',
                background: (theme) => theme.palette.mode === 'dark'
                  ? 'linear-gradient(90deg, #66bb6a, #a5d6a7, #66bb6a)'
                  : 'linear-gradient(90deg, #4caf50, #81c784, #4caf50)',
                backgroundSize: '200% 100%',
                animation: 'shimmer 2s infinite',
                '@keyframes shimmer': {
                  '0%': { backgroundPosition: '-200% 0' },
                  '100%': { backgroundPosition: '200% 0' }
                }
              }}
            />
          )}
          
          <CardContent>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', gap: 3 }}>
              {/* Main Content */}
              <Box sx={{ flex: 1 }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                  <Typography variant="subtitle1" fontWeight="bold">
                    {rec.featureName}
                  </Typography>
                  
                  <Tooltip title={isLocked ? "Unlock recommendation" : "Lock recommendation to prevent changes"} arrow>
                    <IconButton
                      size="small"
                      onClick={() => toggleRecommendationLock(lockId)}
                      sx={{ 
                        color: isLocked ? 'warning.main' : 'text.secondary',
                        '&:hover': {
                          bgcolor: isLocked ? 'warning.light' : 'action.hover'
                        }
                      }}
                    >
                      {isLocked ? <LockIcon fontSize="small" /> : <LockOpenIcon fontSize="small" />}
                    </IconButton>
                  </Tooltip>
                </Box>

                <Box sx={{ mb: 2 }}>
                  <Typography variant="body2" sx={{ mb: 1 }}>
                    {rec.enhancedDescription || rec.description}
                  </Typography>
                  
                  <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                    <Tooltip 
                      title={
                        <Box>
                          <Typography variant="subtitle2" sx={{ fontWeight: 'bold', mb: 0.5 }}>
                            {getCostLabel(rec.costLevel)}
                          </Typography>
                          <Typography variant="body2">
                            {getCostDescription(rec.costLevel)}
                          </Typography>
                        </Box>
                      }
                      arrow
                    >
                      <Chip
                        label={getCostDisplay(rec.costLevel)}
                        size="small"
                        sx={{
                          bgcolor: getCostColor(rec.costLevel),
                          color: 'white',
                          fontWeight: 'bold',
                          cursor: 'help',
                          '& .MuiChip-label': {
                            px: 1
                          }
                        }}
                      />
                    </Tooltip>
                    
                    <Chip
                      label={`Priority: ${rec.importance || 'Medium'}`}
                      size="small"
                      sx={{
                        bgcolor: getImportanceColor(rec.importance),
                        color: 'white',
                        fontWeight: 'bold'
                      }}
                    />
                  </Box>
                </Box>

                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1, mb: 2 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <Chip label="Current" size="small" variant="outlined" />
                    <Typography variant="body2">{rec.currentOption}</Typography>
                  </Box>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <Chip label="Recommended" size="small" color="primary" />
                    <Typography variant="body2" fontWeight="medium">{rec.recommendedOption}</Typography>
                  </Box>
                </Box>

                <Typography variant="body2" color="text.secondary">
                  {rec.description}
                </Typography>
              </Box>

              {/* Action Buttons - Right Side */}
              <Box sx={{ 
                display: 'flex', 
                flexDirection: 'column', 
                gap: 1.5,
                alignItems: 'flex-end',
                minWidth: '150px'
              }}>
                <Button
                  variant={isAlreadySet ? "outlined" : isApplied ? "contained" : "contained"}
                  color={isAlreadySet ? "inherit" : isApplied ? "success" : "primary"}
                  size="small"
                  disabled={isLocked || isAlreadySet || isApplying}
                  onClick={() => toggleRecommendation(rec)}
                  startIcon={
                    isApplying ? <CircularProgress size={16} /> :
                    isAlreadySet ? <CheckIcon /> : 
                    isApplied ? <CheckIcon /> : null
                  }
                  sx={{
                    width: '140px',
                    height: '36px',
                    fontSize: '0.75rem',
                    ...(isApplied && {
                      '&:hover': {
                        bgcolor: 'warning.main',
                        color: 'white',
                      }
                    })
                  }}
                >
                  {isApplying ? (isApplied ? 'Reverting...' : 'Applying...') :
                   isAlreadySet ? 'Already Set' : 
                   isApplied ? 'Revert Change' : 'Apply Change'}
                </Button>

                <Tooltip title="Get detailed implementation guidance from AI" arrow>
                  <Button
                    variant="outlined"
                    size="small"
                    onClick={() => askChatAboutRecommendation(rec, rec)}
                    startIcon={<SmartToyIcon />}
                    sx={{ 
                      width: '140px',
                      height: '36px',
                      fontSize: '0.75rem',
                      borderColor: 'primary.main',
                      color: 'primary.main',
                      '&:hover': {
                        bgcolor: 'primary.light',
                        borderColor: 'primary.main'
                      }
                    }}
                  >
                    Get More Insight
                  </Button>
                </Tooltip>
              </Box>
            </Box>
          </CardContent>
        </Card>
      </motion.div>
    );
  };

  // Generate detailed prompt for chatbot about specific recommendation
  const generateRecommendationPrompt = (rec: RiskMitigationRecommendation, enhanced?: RiskMitigationRecommendation | null) => {
    const costLevel = enhanced?.costLevel || 2;
    const importance = enhanced?.importance || 'Medium';
    const costDisplay = '$'.repeat(Math.min(Math.max(costLevel, 1), 4));
    
    return `I need detailed guidance on implementing this specific cybersecurity recommendation:

**Recommendation:** ${rec.featureName}
**Current Setting:** ${rec.currentOption}
**Recommended Change:** ${rec.recommendedOption}
**Cost Level:** ${costDisplay} 
**Priority:** ${importance}

Please provide detailed advice on:
1. Step-by-step implementation plan
2. Potential challenges and how to overcome them
3. Timeline and resource requirements
4. How this change will specifically impact my project's security
5. Best practices for maintaining this security measure
6. Any complementary security measures I should consider

Please be specific to construction industry cybersecurity and consider my project context.`;
  };

  // Function to switch to chatbot with pre-loaded prompt
  const askChatAboutRecommendation = (rec: RiskMitigationRecommendation, enhanced?: RiskMitigationRecommendation | null) => {
    const prompt = generateRecommendationPrompt(rec, enhanced);
    setChatInput(prompt);
    setActiveTab(1); // Switch to chatbot tab
  };

  // Enhanced Recommendation Card Component (keep for backward compatibility)
  const EnhancedRecommendationCard = ({ 
    rec, 
    index 
  }: { 
    rec: RiskMitigationRecommendation; 
    index: number; 
  }) => {
    const [enhanced, setEnhanced] = useState<RiskMitigationRecommendation | null>(null);
    const [isLoadingEnhancement, setIsLoadingEnhancement] = useState(false);

    const recommendationId = `${rec.featureGroup}-${rec.recommendedOption}`;
    const persistentId = `${rec.featureGroup}-${rec.currentOption}-to-${rec.recommendedOption}`;
    const lockId = `${rec.featureGroup}-${rec.featureName}`;
    
    const isApplied = appliedRecommendations.has(recommendationId) || appliedRecommendations.has(persistentId);
    const isLocked = lockedRecommendations.has(lockId);
    const isAlreadySet = rec.currentOption === rec.recommendedOption;
    const isApplying = applyingRecommendation === recommendationId;

    // Load enhanced description on mount
    useEffect(() => {
      let cancelled = false;
      
      const loadEnhancement = async () => {
        if (cancelled) return;
        
        const cacheKey = `${rec.featureGroup}-${rec.featureName}-${rec.description}`;
        
        // Check cache first
        if (enhancedDescriptions.has(cacheKey)) {
          if (!cancelled) {
            setEnhanced(enhancedDescriptions.get(cacheKey)!);
            setIsLoadingEnhancement(false);
          }
          return;
        }
        
        if (!cancelled) {
          setIsLoadingEnhancement(true);
        }
        
        try {
          const enhancedRec = await getEnhancedRecommendation(rec);
          if (!cancelled) {
            setEnhanced(enhancedRec);
          }
        } catch (error) {
          console.error('Failed to load enhancement:', error);
          if (!cancelled) {
            setEnhanced(rec);
          }
        } finally {
          if (!cancelled) {
            setIsLoadingEnhancement(false);
          }
        }
      };

      // Reset enhanced state when rec changes to ensure fresh loading
      setEnhanced(null);
      setIsLoadingEnhancement(true);
      
      // Small delay to batch multiple simultaneous requests
      const timeoutId = setTimeout(() => {
        loadEnhancement();
      }, 50);

      return () => {
        cancelled = true;
        clearTimeout(timeoutId);
      };
    }, [rec.featureGroup, rec.featureName, rec.description, rec.currentOption, rec.recommendedOption]); // More comprehensive dependencies

    const getCostDisplay = (costLevel?: number) => {
      if (!costLevel) return '$$';
      return '$'.repeat(Math.min(Math.max(costLevel, 1), 4));
    };

    const getCostColor = (costLevel?: number) => {
      if (!costLevel) return '#ff9800';
      switch (costLevel) {
        case 1: return '#4caf50'; // Green for low cost
        case 2: return '#ff9800'; // Orange for moderate cost
        case 3: return '#f44336'; // Red for high cost
        case 4: return '#d32f2f'; // Dark red for very high cost
        default: return '#ff9800';
      }
    };

    const getImportanceColor = (importance?: string) => {
      switch (importance?.toLowerCase()) {
        case 'critical': return '#d32f2f';
        case 'high': return '#f44336';
        case 'medium': return '#ff9800';
        case 'low': return '#4caf50';
        default: return '#ff9800';
      }
    };

    return (
      <motion.div
        key={index}
        layout
        initial={{ opacity: 0, y: 20 }}
        animate={{ 
          opacity: 1, 
          y: 0,
          scale: isApplied ? [1, 1.02, 1] : 1,
        }}
        transition={{ 
          duration: 0.3,
          delay: index * 0.1,
          scale: { duration: 0.5, times: [0, 0.5, 1] }
        }}
      >
        <Card 
          variant="outlined" 
          sx={{
            position: 'relative',
            overflow: 'hidden',
            opacity: isLocked ? 0.7 : 1,
            ...(isApplied && {
              bgcolor: (theme) => theme.palette.mode === 'dark' 
                        ? 'rgba(76, 175, 80, 0.15)' 
                        : 'success.light',
              borderColor: 'success.main',
              boxShadow: (theme) => theme.palette.mode === 'dark'
                ? '0 0 20px rgba(76, 175, 80, 0.4)'
                : '0 0 20px rgba(76, 175, 80, 0.3)',
              color: (theme) => theme.palette.mode === 'dark' 
                ? 'success.light' 
                : 'inherit',
            }),
            ...(isLocked && {
              borderColor: 'grey.400',
              bgcolor: 'grey.50',
            })
          }}
        >
          {isApplied && (
            <Box
              sx={{
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                height: 4,
                bgcolor: 'success.main',
                background: (theme) => theme.palette.mode === 'dark'
                  ? 'linear-gradient(90deg, #66bb6a, #a5d6a7, #66bb6a)'
                  : 'linear-gradient(90deg, #4caf50, #81c784, #4caf50)',
                backgroundSize: '200% 100%',
                animation: 'shimmer 2s infinite',
                '@keyframes shimmer': {
                  '0%': { backgroundPosition: '-200% 0' },
                  '100%': { backgroundPosition: '200% 0' }
                }
              }}
            />
          )}
          
          <CardContent>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
              <Box sx={{ flex: 1 }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                  <Typography variant="subtitle1" fontWeight="bold">
                    {rec.featureName}
                  </Typography>
                  
                  {/* Lock Button */}
                  <Tooltip title={isLocked ? "Unlock recommendation" : "Lock recommendation to prevent changes"} arrow>
                    <IconButton
                      size="small"
                      onClick={() => toggleRecommendationLock(lockId)}
                      sx={{ 
                        color: isLocked ? 'warning.main' : 'text.secondary',
                        '&:hover': {
                          bgcolor: isLocked ? 'warning.light' : 'action.hover'
                        }
                      }}
                    >
                      {isLocked ? <LockIcon fontSize="small" /> : <LockOpenIcon fontSize="small" />}
                    </IconButton>
                  </Tooltip>
                </Box>

                {/* Enhanced Description */}
                {isLoadingEnhancement ? (
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                    <CircularProgress size={16} />
                    <Typography variant="body2" color="text.secondary">
                      Loading analysis...
                    </Typography>
                  </Box>
                ) : enhanced?.enhancedDescription ? (
                  <Box sx={{ mb: 2 }}>
                    <Typography variant="body2" sx={{ mb: 1 }}>
                      {enhanced.enhancedDescription}
                    </Typography>
                    
                    {/* Cost, Feasibility, and Importance Tags */}
                    <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                      <Chip
                        label={getCostDisplay(enhanced.costLevel)}
                        size="small"
                        sx={{
                          bgcolor: getCostColor(enhanced.costLevel),
                          color: 'white',
                          fontWeight: 'bold',
                          '& .MuiChip-label': { px: 1 }
                        }}
                      />
                      
                      {enhanced.importance && (
                        <Chip
                          label={`${enhanced.importance} Priority`}
                          size="small"
                          sx={{
                            bgcolor: getImportanceColor(enhanced.importance),
                            color: 'white',
                            '& .MuiChip-label': { px: 1 }
                          }}
                        />
                      )}
                    </Box>
                  </Box>
                ) : (
                  <Typography 
                    variant="body2" 
                    sx={{ 
                      mb: 2,
                      color: isApplied 
                        ? (theme) => theme.palette.mode === 'dark' 
                          ? 'rgba(255, 255, 255, 0.8)' 
                          : 'text.secondary'
                        : 'text.secondary'
                    }}
                  >
                    {rec.description}
                  </Typography>
                )}
              </Box>

                             {/* Buttons Container */}
               <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1, ml: 2 }}>
                 {/* Apply Button */}
                 <Button
                   variant={isApplied ? "outlined" : isAlreadySet ? "outlined" : "contained"}
                   color={isApplied ? "success" : "primary"}
                   size="small"
                   onClick={() => !isApplied && !isAlreadySet && !isApplying && !isUpdatingStrategy && !isLocked && applyRecommendation(rec)}
                   disabled={isApplied || isAlreadySet || isApplying || isUpdatingStrategy || isLocked}
                   sx={{ 
                     minWidth: 120,
                     transition: 'all 0.3s ease-in-out',
                     ...(isApplied && {
                       bgcolor: (theme) => theme.palette.mode === 'dark' 
                         ? 'rgba(76, 175, 80, 0.2)'
                         : 'success.light',
                       color: (theme) => theme.palette.mode === 'dark'
                         ? 'success.light'
                         : 'success.main',
                       borderColor: 'success.main',
                       '&:hover': {
                         bgcolor: (theme) => theme.palette.mode === 'dark' 
                           ? 'rgba(76, 175, 80, 0.25)'
                           : 'success.light',
                       }
                     }),
                     ...(isAlreadySet && !isApplied && {
                       bgcolor: (theme) => theme.palette.mode === 'dark' 
                         ? 'rgba(158, 158, 158, 0.12)'
                         : 'grey.100',
                       color: (theme) => theme.palette.mode === 'dark'
                         ? 'grey.400'
                         : 'grey.600',
                       borderColor: (theme) => theme.palette.mode === 'dark'
                         ? 'grey.700'
                         : 'grey.300',
                       '&:hover': {
                         bgcolor: (theme) => theme.palette.mode === 'dark' 
                           ? 'rgba(158, 158, 158, 0.15)'
                           : 'grey.200',
                       }
                     }),
                     ...(isLocked && {
                       bgcolor: 'grey.300',
                       color: 'grey.600',
                       borderColor: 'grey.400',
                     })
                   }}
                   startIcon={
                     isApplying ? (
                       <PulsingLoader size={16} color="inherit" />
                     ) : isApplied ? (
                       <motion.div
                         initial={{ rotate: 0, scale: 0 }}
                         animate={{ rotate: 360, scale: 1 }}
                         transition={{ 
                           duration: 0.6, 
                           type: "spring", 
                           stiffness: 200,
                           delay: 0.1 
                         }}
                       >
                         <CheckIcon />
                       </motion.div>
                     ) : isLocked ? (
                       <LockIcon />
                     ) : null
                   }
                 >
                   {isApplying ? (
                     <motion.div
                       initial={{ opacity: 0 }}
                       animate={{ opacity: 1 }}
                       transition={{ duration: 0.2 }}
                     >
                       Applying...
                     </motion.div>
                   ) : isApplied ? (
                     <motion.div
                       initial={{ scale: 0.8, opacity: 0 }}
                       animate={{ scale: 1, opacity: 1 }}
                       transition={{ duration: 0.4, type: "spring", stiffness: 200 }}
                     >
                       Applied
                     </motion.div>
                   ) : isLocked ? (
                     "Locked"
                   ) : isAlreadySet ? (
                     "Already Set"
                   ) : (
                     "Apply Change"
                   )}
                 </Button>

                 {/* Get More Insight Button */}
                 <Button
                   variant="outlined"
                   color="info"
                   size="small"
                   onClick={() => askChatAboutRecommendation(rec, enhanced)}
                   sx={{
                     minWidth: 120,
                     borderColor: 'info.main',
                     color: 'info.main',
                     '&:hover': {
                       bgcolor: 'info.light',
                       borderColor: 'info.dark',
                     }
                   }}
                   startIcon={<SmartToyIcon />}
                 >
                   Get More Insight
                 </Button>
               </Box>
            </Box>

            {/* Current vs Recommended */}
            <Box sx={{ display: 'flex', gap: 4, alignItems: 'center' }}>
              <Box>
                <Typography variant="caption" color="text.secondary" display="block">
                  Current
                </Typography>
                <Typography variant="body2" fontWeight="medium">
                  {rec.currentOption}
                </Typography>
              </Box>
              <Box sx={{ color: 'primary.main' }}>
                →
              </Box>
              <Box>
                <Typography variant="caption" color="text.secondary" display="block">
                  Recommended
                </Typography>
                <Typography variant="body2" color="primary.main" fontWeight="bold">
                  {rec.recommendedOption}
                </Typography>
              </Box>
            </Box>
          </CardContent>
        </Card>
      </motion.div>
    );
  };

  // Trigger risk mitigation analysis when form is completed
  useEffect(() => {
    if (isFormComplete() && !riskMitigationStrategy) {
      // This is the initial load - analyzeRiskMitigation already sets to overview
      analyzeRiskMitigation();
    }
  }, [riskResults]);

  // Track loading state when round changes
  useEffect(() => {
    if (riskMitigationStrategy && selectedRound > 0) {
      const round = riskMitigationStrategy.rounds.find(r => r.roundNumber === selectedRound);
      if (round) {
        const roundRecommendationKeys = round.recommendations.map(rec => 
          `${rec.featureGroup}-${rec.featureName}-${rec.description}`
        );
        
        // Check if any recommendations need loading
        const needsLoading = roundRecommendationKeys.some(key => !enhancedDescriptions.has(key));
        if (needsLoading) {
          // Mark all unloaded recommendations as loading
          setLoadingRecommendations(prev => {
            const newSet = new Set(prev);
            roundRecommendationKeys.forEach(key => {
              if (!enhancedDescriptions.has(key)) {
                newSet.add(key);
              }
            });
            return newSet;
          });
        }
      }
    }
  }, [selectedRound, riskMitigationStrategy, enhancedDescriptions]);

  // Dev function to auto-fill form with sample data
  const autoFillForm = () => {
    // Admin check for security
    if (!isAdmin()) {
      console.warn('⚠️ Access Denied: Admin privileges required for dev tools');
      return;
    }
    
    const sampleData: ProjectInfo = {
      // Section 1: Basic Project Information
      projectDuration: '12-24m',
      projectType: 'commercial',
      hasCyberLegalTeam: 'no',
      companyScale: '61-100',
      projectPhase: 'construction',

      // Section 2: Project Structure
      layer1Teams: '11-20',
      layer2Teams: '21-30',
      layer3Teams: '<=10',
      teamOverlap: '41-60',

      // Section 3: Technical Factors
      hasITTeam: 'unsure',
      devicesWithFirewall: '21-40',
      networkType: 'both',
      phishingFailRate: '61-80',

      // Section 4: Security Practices
      governanceLevel: 'level2',
      allowPasswordReuse: 'yes',
      usesMFA: 'no',

      // Additional fields (not used in calculation but part of interface)
      regulatoryRequirements: '',
      stakeholderCount: '',
      thirdPartyVendors: '',
      remoteWorkLevel: '',
      cloudServices: '',
      dataClassification: '',
      bmsIntegration: '',
      accessControl: '',
      securityMonitoring: '',
      incidentResponse: '',
      backupStrategy: '',
      securityCertifications: '',
      securityAwareness: '',
      securityTeamSize: '',
      thirdPartySecurityReq: '',
      securityBudget: ''
    };

    setProjectInfo(sampleData);
    
    if (devMode) {
      console.log('🛠️ Dev Mode: Form auto-filled with sample data', sampleData);
    }
  };

  // Dev function to clear all form data
  const clearForm = () => {
    // Admin check for security
    if (!isAdmin()) {
      console.warn('⚠️ Access Denied: Admin privileges required for dev tools');
      return;
    }
    setProjectInfo({
      projectDuration: '', projectType: '', hasCyberLegalTeam: '', companyScale: '', projectPhase: '',
      layer1Teams: '', layer2Teams: '', layer3Teams: '', teamOverlap: '', hasITTeam: '', devicesWithFirewall: '', networkType: '',
      phishingFailRate: '', governanceLevel: '', allowPasswordReuse: '', usesMFA: '',
      regulatoryRequirements: '', stakeholderCount: '', thirdPartyVendors: '', remoteWorkLevel: '',
      cloudServices: '', dataClassification: '', bmsIntegration: '', accessControl: '',
      securityMonitoring: '', incidentResponse: '', backupStrategy: '', securityCertifications: '',
      securityAwareness: '', securityTeamSize: '', thirdPartySecurityReq: '', securityBudget: ''
    });
    setRiskReductions([]);
    
    if (devMode) {
      console.log('🛠️ Dev Mode: Form cleared');
    }
  };

  // --- NEW: Mock mitigation strategy generator ---
  const generateMockMitigationStrategy = (): RiskMitigationStrategy => {
    // Helper to distribute reduction among recommendations
    const distributeReduction = (total: number, count: number) => {
      // Give higher reduction to first rec, then spread remainder
      if (count === 1) return [total];
      if (count === 2) return [Math.round(total * 0.6 * 100) / 100, Math.round(total * 0.4 * 100) / 100];
      // For 3+, first gets 45%, second 35%, rest split
      const first = Math.round(total * 0.45 * 100) / 100;
      const second = Math.round(total * 0.35 * 100) / 100;
      const rest = total - first - second;
      const restEach = Math.round((rest / (count - 2)) * 100) / 100;
      return [first, second, ...Array(count - 2).fill(restEach)];
    };
    return {
      initialRisk: 0.92,
      finalRisk: 0.22,
      totalReduction: 0.7,
      totalReductionPercentage: 76.1,
      implementationPriority: 'high',
      rounds: [
        {
          roundNumber: 1,
          features: ['Firewall Coverage', 'MFA', 'Vendor Security'],
          currentRisk: 0.92,
          projectedRisk: 0.61,
          riskReduction: 0.31,
          reductionPercentage: 33.7,
          recommendations: (() => {
            const recs = [
              {
                featureGroup: '3.2',
                featureName: 'Firewall Coverage',
                currentOption: 'Partial',
                recommendedOption: 'Full',
                optionIndex: 2,
                description: 'Upgrade all devices to have firewall protection.',
                enhancedDescription: 'Ensures all endpoints are protected from network threats.',
                costLevel: 2,
                importance: 'High',
              },
              {
                featureGroup: '4.3',
                featureName: 'MFA',
                currentOption: 'No',
                recommendedOption: 'Yes',
                optionIndex: 1,
                description: 'Enable multi-factor authentication for all users.',
                enhancedDescription: 'Adds a strong layer of defense against account compromise.',
                costLevel: 1,
                importance: 'High',
              },
              {
                featureGroup: '3.5',
                featureName: 'Vendor Security',
                currentOption: 'Basic',
                recommendedOption: 'Advanced',
                optionIndex: 2,
                description: 'Require advanced security controls for all vendors.',
                enhancedDescription: 'Reduces supply chain risk from third parties.',
                costLevel: 3,
                importance: 'Medium',
              },
            ];
            const reductions = distributeReduction(33.7, recs.length);
            return recs.map((rec, i) => ({
              ...rec,
              riskReduction: Math.round((reductions[i] / 100) * 0.92 * 1000) / 1000, // relative to initial risk
              riskReductionPercentage: reductions[i],
            }));
          })(),
        },
        {
          roundNumber: 2,
          features: ['Password Reuse Policy', 'Security Training Effectiveness'],
          currentRisk: 0.61,
          projectedRisk: 0.33,
          riskReduction: 0.28,
          reductionPercentage: 45.9,
          recommendations: (() => {
            const recs = [
              {
                featureGroup: '4.2',
                featureName: 'Password Reuse Policy',
                currentOption: 'Yes',
                recommendedOption: 'No',
                optionIndex: 1,
                description: 'Disallow password reuse across all project accounts.',
                enhancedDescription: 'Restricting password reuse helps prevent credential stuffing attacks.',
                costLevel: 1,
                importance: 'High',
              },
              {
                featureGroup: '3.4',
                featureName: 'Security Training Effectiveness',
                currentOption: '61-80%',
                recommendedOption: '<=20',
                optionIndex: 0,
                description: 'Improve security awareness training to reduce phishing test failure rate.',
                enhancedDescription: 'Better training will lower the risk of successful phishing attacks.',
                costLevel: 2,
                importance: 'Medium',
              },
            ];
            const reductions = distributeReduction(45.9, recs.length);
            return recs.map((rec, i) => ({
              ...rec,
              riskReduction: Math.round((reductions[i] / 100) * 0.61 * 1000) / 1000, // relative to round start
              riskReductionPercentage: reductions[i],
            }));
          })(),
        },
        {
          roundNumber: 3,
          features: ['Governance Level'],
          currentRisk: 0.33,
          projectedRisk: 0.22,
          riskReduction: 0.11,
          reductionPercentage: 33.3,
          recommendations: [
            {
              featureGroup: '4.1',
              featureName: 'Governance Level',
              currentOption: 'level2',
              recommendedOption: 'level5',
              optionIndex: 4,
              description: 'Elevate governance maturity to exemplary standards.',
              enhancedDescription: 'Strong governance ensures long-term security and compliance.',
              costLevel: 3,
              importance: 'Medium',
              riskReduction: 0.11,
              riskReductionPercentage: 33.3,
            },
          ],
        },
      ],
    };
  };

  // --- NEW: Refresh results/strategy when useRandomResults changes ---
  useEffect(() => {
    if (!isFormComplete()) return;
    // When toggling random results, refresh risk results and mitigation strategy
    const refresh = async () => {
      setIsLoading(true);
      setApiError(null);
      try {
        if (useRandomResults) {
          const results = generateRandomResults();
          setRiskResults(results);
          // Ensure mock mitigation strategy is set in demo mode
          const mockStrategy = generateMockMitigationStrategy();
          setRiskMitigationStrategy(mockStrategy);
          // Ensure enhanced descriptions are loaded for mock strategy
          await loadAllEnhancedDescriptions(mockStrategy);
        } else {
          const results = await riskApiService.calculateRisk(projectInfo);
          setRiskResults(results);
          // Re-analyze mitigation with real data
          await analyzeRiskMitigation();
        }
      } catch (error) {
        setApiError((error as Error).message || 'Failed to update results');
      } finally {
        setIsLoading(false);
      }
    };
    refresh();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [useRandomResults]);

  // Enhanced Export chat functionality with modern design and text formatting
  const handleExportChat = () => {
    if (!currentConversation) return;

    const doc = new jsPDF() as ExtendedJsPDF;
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - (2 * margin);
    let yOffset = 20;

    // Modern color palette
    const colors = {
      primary: [79, 70, 229] as [number, number, number], // Indigo
      secondary: [6, 182, 212] as [number, number, number], // Cyan
      accent: [16, 185, 129] as [number, number, number], // Emerald
      success: [34, 197, 94] as [number, number, number],
      warning: [245, 158, 11] as [number, number, number],
      error: [239, 68, 68] as [number, number, number],
      critical: [185, 28, 28] as [number, number, number],
      text: [15, 23, 42] as [number, number, number],
      textLight: [100, 116, 139] as [number, number, number],
      background: [248, 250, 252] as [number, number, number],
      white: [255, 255, 255] as [number, number, number],
      gray: [226, 232, 240] as [number, number, number],
      darkGray: [71, 85, 105] as [number, number, number]
    };

    // Helper function to check if we need a new page
    const checkPageBreak = (neededSpace: number) => {
      if (yOffset + neededSpace > pageHeight - 50) {
        doc.addPage();
        yOffset = margin;
        return true;
      }
      return false;
    };

    // Enhanced text parsing with proper page break handling
    const parseAndFormatText = (text: string, x: number, startY: number, maxWidth: number) => {
      yOffset = startY; // Use global yOffset for proper page break tracking
      const lineHeight = 6;
      
      // Clean and normalize the text
      const cleanText = text
        .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markers for now
        .replace(/\*(.*?)\*/g, '$1') // Remove italic markers
        .replace(/#{1,3}\s+/g, '') // Remove header markers
        .trim();

      // Split into paragraphs
      const paragraphs = cleanText.split(/\n\s*\n/);
      
      paragraphs.forEach((paragraph, paragraphIndex) => {
        if (!paragraph.trim()) return;
        
        // Split paragraph into lines that fit the width
        const lines = paragraph.split('\n');
        
        lines.forEach(line => {
          if (!line.trim()) {
            // Check page break for empty lines
            if (checkPageBreak(lineHeight)) {
              // Page break occurred, continue on new page
            }
            yOffset += lineHeight;
            return;
          }
          
          // Handle bullet points
          if (line.match(/^[\s]*[-*•]\s+/)) {
            const bulletText = line.replace(/^[\s]*[-*•]\s+/, '').trim();
            
            // Pre-calculate space needed
            const wrappedBullet = doc.splitTextToSize(bulletText, maxWidth - 12);
            const spaceNeeded = wrappedBullet.length * lineHeight + 2;
            
            // Check page break before rendering
            if (checkPageBreak(spaceNeeded)) {
              // Page break occurred, continue on new page
            }
            
            // Add bullet point
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10);
            doc.setTextColor(colors.primary[0], colors.primary[1], colors.primary[2]);
            doc.text('•', x, yOffset);
            
            // Add bullet text with proper wrapping
            doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
            doc.text(wrappedBullet, x + 10, yOffset);
            yOffset += spaceNeeded;
            return;
          }
          
          // Handle numbered lists
          if (line.match(/^\s*\d+\.\s+/)) {
            const match = line.match(/^(\s*)(\d+\.\s+)(.*)$/);
            if (match) {
              const [, indent, number, text] = match;
              
              // Pre-calculate space needed
              const wrappedList = doc.splitTextToSize(text.trim(), maxWidth - 20);
              const spaceNeeded = wrappedList.length * lineHeight + 2;
              
              // Check page break before rendering
              if (checkPageBreak(spaceNeeded)) {
                // Page break occurred, continue on new page
              }
              
              // Add number
    doc.setFont('helvetica', 'bold');
              doc.setFontSize(10);
              doc.setTextColor(colors.primary[0], colors.primary[1], colors.primary[2]);
              doc.text(number.trim(), x, yOffset);
              
              // Add list text with proper wrapping
              doc.setFont('helvetica', 'normal');
              doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
              doc.text(wrappedList, x + 15, yOffset);
              yOffset += spaceNeeded;
            }
            return;
          }
          
          // Regular text with proper wrapping and page break handling
          doc.setFont('helvetica', 'normal');
    doc.setFontSize(10);
          doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
          
          const wrappedText = doc.splitTextToSize(line.trim(), maxWidth);
          
          // Handle each wrapped line individually for page breaks
          wrappedText.forEach((wrappedLine: string, lineIndex: number) => {
            // Check page break for each line
            if (checkPageBreak(lineHeight + 1)) {
              // Page break occurred, continue on new page
            }
            
            doc.text(wrappedLine, x, yOffset);
            yOffset += lineHeight + 1;
          });
        });
        
        // Add space between paragraphs
        if (paragraphIndex < paragraphs.length - 1) {
          if (checkPageBreak(lineHeight)) {
            // Page break occurred, continue on new page
          }
          yOffset += lineHeight;
        }
      });

      return yOffset;
    };

    // Modern header with gradient effect
    const addModernHeader = () => {
      // Header background with gradient effect
      doc.setFillColor(colors.primary[0], colors.primary[1], colors.primary[2]);
      doc.rect(0, 0, pageWidth, 50, 'F');
      
      // Add subtle accent bar
      doc.setFillColor(colors.secondary[0], colors.secondary[1], colors.secondary[2]);
      doc.rect(0, 50, pageWidth, 3, 'F');
      
      // Title
      doc.setTextColor(colors.white[0], colors.white[1], colors.white[2]);
      doc.setFontSize(24);
      doc.setFont('helvetica', 'bold');
      doc.text('AI CONVERSATION EXPORT', pageWidth / 2, 25, { align: 'center' });
      
      // Subtitle
      doc.setFontSize(12);
      doc.setFont('helvetica', 'normal');
      doc.text('Cyber Risk Analysis Consultation', pageWidth / 2, 40, { align: 'center' });
      
      yOffset = 65;
    };

    // Add conversation metadata section
    const addMetadataSection = () => {
      checkPageBreak(40);
      
      // Metadata background
      doc.setFillColor(colors.background[0], colors.background[1], colors.background[2]);
      doc.rect(margin, yOffset, contentWidth, 35, 'F');
      doc.setDrawColor(colors.gray[0], colors.gray[1], colors.gray[2]);
      doc.rect(margin, yOffset, contentWidth, 35);
      
      // Metadata content
      doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
      doc.setFontSize(11);
      doc.setFont('helvetica', 'bold');
      doc.text('CONVERSATION DETAILS', margin + 10, yOffset + 12);
      
      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(colors.textLight[0], colors.textLight[1], colors.textLight[2]);
      
      const conversationDate = currentConversation.lastUpdated.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      
      const conversationTime = currentConversation.lastUpdated.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit'
      });
      
      doc.text(`Conversation Date: ${conversationDate} at ${conversationTime}`, margin + 10, yOffset + 20);
      doc.text(`Messages: ${currentConversation.messages.length} | Export Date: ${new Date().toLocaleDateString()}`, margin + 10, yOffset + 27);
      
      yOffset += 45;
    };

    // Add risk context section
    const addRiskContextSection = () => {
      checkPageBreak(60);
      
      // Section header
      doc.setFillColor(colors.primary[0], colors.primary[1], colors.primary[2]);
      doc.rect(margin, yOffset, contentWidth, 20, 'F');
      
      doc.setTextColor(colors.white[0], colors.white[1], colors.white[2]);
      doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
      doc.text('RISK ASSESSMENT CONTEXT', margin + 10, yOffset + 13);
      
      yOffset += 25;
      
      // Risk scores table
      const riskScores = Object.entries(riskResults);
      const tableWidth = contentWidth;
      const colWidth = tableWidth / 3;
      
      riskScores.forEach(([riskType, analysis], index) => {
        checkPageBreak(18);
        
        const riskColor = analysis.level === 'critical' ? colors.critical :
                         analysis.level === 'high' ? colors.error :
                         analysis.level === 'medium' ? colors.warning :
                         colors.success;
        
        // Row background
        const rowColor = index % 2 === 0 ? colors.background : colors.white;
        doc.setFillColor(rowColor[0], rowColor[1], rowColor[2]);
        doc.rect(margin, yOffset, contentWidth, 15, 'F');
        
        // Risk type
        doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
    doc.setFontSize(10);
        doc.setFont('helvetica', 'bold');
        const riskName = riskType.charAt(0).toUpperCase() + riskType.slice(1).replace(/([A-Z])/g, ' $1');
        doc.text(riskName, margin + 5, yOffset + 9);
        
        // Score with progress bar
        const scoreX = margin + colWidth;
        doc.setFillColor(colors.gray[0], colors.gray[1], colors.gray[2]);
        doc.rect(scoreX, yOffset + 4, 40, 7, 'F');
        
        const scorePercent = analysis.score / 100;
        doc.setFillColor(riskColor[0], riskColor[1], riskColor[2]);
        doc.rect(scoreX, yOffset + 4, 40 * scorePercent, 7, 'F');
        
        doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
    doc.setFont('helvetica', 'normal');
        doc.text(`${analysis.score}%`, scoreX + 45, yOffset + 9);
        
        // Risk level
        doc.setTextColor(riskColor[0], riskColor[1], riskColor[2]);
        doc.setFont('helvetica', 'bold');
        doc.text(analysis.level.toUpperCase(), margin + 2 * colWidth, yOffset + 9);
        
        yOffset += 18;
      });
      
      yOffset += 10;
    };

    // Add conversation messages
    const addConversationMessages = () => {
      // Section header
      doc.setFillColor(colors.secondary[0], colors.secondary[1], colors.secondary[2]);
      doc.rect(margin, yOffset, contentWidth, 20, 'F');
      
      doc.setTextColor(colors.white[0], colors.white[1], colors.white[2]);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
      doc.text('CONVERSATION HISTORY', margin + 10, yOffset + 13);
      
      yOffset += 30;

    currentConversation.messages.forEach((message, index) => {
        const sender = message.sender === 'user' ? 'You' : 'Dr. CyberBuild AI';
        const timestamp = message.timestamp.toLocaleString('en-US', {
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        checkPageBreak(25);
        
        // Message header with user/AI distinction
        const headerColor = message.sender === 'user' ? colors.primary : colors.secondary;
        doc.setFillColor(headerColor[0], headerColor[1], headerColor[2]);
        doc.roundedRect(margin, yOffset, contentWidth, 16, 2, 2, 'F');
        
        // Sender name and timestamp
        doc.setTextColor(colors.white[0], colors.white[1], colors.white[2]);
      doc.setFont('helvetica', 'bold');
        doc.setFontSize(10);
        doc.text(sender, margin + 8, yOffset + 10);
      
      doc.setFont('helvetica', 'normal');
        doc.setFontSize(8);
        doc.text(timestamp, pageWidth - margin - 8, yOffset + 10, { align: 'right' });
        
        yOffset += 22;
        
        // Message content - render directly with page break handling
        const contentStartY = yOffset;
        
        // Add a small top margin for content
        yOffset += 3;
        
        // Render the text content with proper page break handling
        yOffset = parseAndFormatText(message.text, margin + 8, yOffset, contentWidth - 16);
        yOffset += 8;
        
        // Add separator line between messages (except for the last one)
      if (index < currentConversation.messages.length - 1) {
          doc.setDrawColor(220, 220, 220);
          doc.setLineWidth(0.5);
          doc.line(margin + 15, yOffset, pageWidth - margin - 15, yOffset);
          yOffset += 8;
        }
      });
    };

    // Generate the PDF
    addModernHeader();
    addMetadataSection();
    addRiskContextSection();
    addConversationMessages();

    // Add professional footer to all pages
    const pageCount = (doc as any).internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      
      // Footer background
      doc.setFillColor(colors.background[0], colors.background[1], colors.background[2]);
      doc.rect(0, pageHeight - 25, pageWidth, 25, 'F');
      
      // Footer content
      doc.setTextColor(colors.textLight[0], colors.textLight[1], colors.textLight[2]);
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      
      // Company branding
      doc.setFont('helvetica', 'bold');
      doc.text('CYBER RISK DASHBOARD', margin, pageHeight - 12);
      
      // Page number (centered)
      doc.setFont('helvetica', 'normal');
      doc.text(`Page ${i} of ${pageCount}`, pageWidth / 2 - 10, pageHeight - 12);
      
      // Export date (right)
      doc.text(new Date().toLocaleDateString(), pageWidth - margin - 30, pageHeight - 12);
      
      // Decorative line
      doc.setDrawColor(colors.accent[0], colors.accent[1], colors.accent[2]);
      doc.setLineWidth(1);
      doc.line(margin, pageHeight - 20, pageWidth - margin, pageHeight - 20);
    }

    // Save with descriptive filename
    const safeTitle = currentConversation.title.replace(/[^a-z0-9]/gi, '-').toLowerCase();
    const dateStr = new Date().toISOString().split('T')[0];
    doc.save(`cyber-risk-chat-${safeTitle}-${dateStr}.pdf`);
  };

  // Save project functionality
  const handleSaveProject = () => {
    setSaveDialogOpen(true);
    setSaveError(null);
    setSaveSuccess(false);
  };

  const handleSaveConfirm = async () => {
    if (!projectName.trim()) {
      setSaveError('Please enter a project name');
      return;
    }

    setIsSaving(true);
    setSaveError(null);

    try {
      const projectData = {
        projectName: projectName.trim(),
        projectInfo,
        riskResults,
        mitigationStrategy: riskMitigationStrategy,
        conversations
      };

      await projectService.saveProject(projectData);
      
      setSaveSuccess(true);
      setProjectName('');
      
      // Close dialog after 2 seconds
      setTimeout(() => {
        setSaveDialogOpen(false);
        setSaveSuccess(false);
      }, 2000);

    } catch (error) {
      console.error('Save project error:', error);
      setSaveError((error as Error).message || 'Failed to save project');
    } finally {
      setIsSaving(false);
    }
  };

  const handleSaveCancel = () => {
    setSaveDialogOpen(false);
    setProjectName('');
    setSaveError(null);
    setSaveSuccess(false);
  };

  const [selectedRound, setSelectedRound] = useState(0);
  const [sortBy, setSortBy] = useState('default');

  const getSortedRecommendations = (recs, sortBy) => {
    if (sortBy === 'riskReduction') {
      return [...recs].sort((a, b) => (b.riskReductionPercentage || 0) - (a.riskReductionPercentage || 0));
    }
    if (sortBy === 'cost') {
      return [...recs].sort((a, b) => (a.costLevel || 2) - (b.costLevel || 2));
    }
    if (sortBy === 'priority') {
      const priorityValue = imp => imp === 'High' ? 2 : imp === 'Medium' ? 1 : 0;
      return [...recs].sort((a, b) => priorityValue(b.importance) - priorityValue(a.importance));
    }
    return recs;
  };

  return (
    <Container maxWidth="lg" sx={{ py: 4 }}>
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
      >
        <Typography variant="h4" component="h1" gutterBottom align="center">
          Risk Quantification
        </Typography>

        {/* Admin-only Developer Tools */}
        {isAdmin() && (
          <Box sx={{ display: 'flex', justifyContent: 'center', gap: 4, mb: 3 }}>
            <Tooltip title="Enable development tools: auto-fill form, clear form, and show debug info (Admin Only)" arrow>
              <FormControlLabel
                control={
                  <Switch
                    checked={devMode}
                    onChange={(e) => setDevMode(e.target.checked)}
                    color="secondary"
                  />
                }
                label={
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    <DeveloperModeIcon fontSize="small" />
                    <Typography variant="body2" color="text.secondary">
                      Dev Mode (Admin)
                    </Typography>
                  </Box>
                }
              />
            </Tooltip>
            {devMode && (
              <Box sx={{ display: 'flex', gap: 2, alignItems: 'center' }}>
                <FormControlLabel
                  control={
                    <Switch
                      checked={useRandomResults}
                      onChange={(e) => setUseRandomResults(e.target.checked)}
                      color="primary"
                    />
                  }
                  label={
                    <Typography variant="body2" color="text.secondary">
                      {useRandomResults ? 'Using Random Results' : 'Using AI Model'}
                    </Typography>
                  }
                />
                <Divider orientation="vertical" flexItem />
                <Box sx={{ display: 'flex', gap: 1 }}>
                  <Button
                    variant="outlined"
                    size="small"
                    onClick={autoFillForm}
                    color="success"
                  >
                    Auto-Fill Form
                  </Button>
                  <Button
                    variant="outlined"
                    size="small"
                    onClick={clearForm}
                    color="error"
                  >
                    Clear Form
                  </Button>
                </Box>
              </Box>
            )}
          </Box>
        )}

        {/* Dev Info Panel - Admin Only */}
        {isAdmin() && devMode && (
          <Alert severity="info" sx={{ mb: 3 }}>
            <Typography variant="body2">
              <strong>🛠️ Admin Dev Mode Active</strong> | 
              Form Completion: {getCompletionPercentage()}% | 
              Form Valid: {isFormComplete() ? '✅' : '❌'} | 
              Risk Results: {Object.values(riskResults).some(r => r.score > 0) ? '✅' : '❌'}
            </Typography>
          </Alert>
        )}
        
        <Paper 
          elevation={3} 
          sx={{ 
            p: 3,
            mb: 4,
            minHeight: 'auto',
            display: 'flex',
            flexDirection: 'column',
            position: 'relative',
            overflow: 'visible'
          }}
        >
          {renderCurrentSection()}
        </Paper>

        {renderRiskIndicators()}

        {/* Risk Analysis Tools Section - appears after form completion */}
        {isFormComplete() && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5, delay: 0.3 }}
          >
            <Paper elevation={3} sx={{ mt: 4, p: 3 }}>
              <Typography variant="h5" gutterBottom sx={{ mb: 3, display: 'flex', alignItems: 'center', gap: 1 }}>
                <AutoFixHighIcon color="primary" />
                Risk Analysis Tools
              </Typography>
              
              <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
                <Tabs value={activeTab} onChange={(e, newValue) => setActiveTab(newValue)}>
                  <Tab 
                    label="Risk Reduction" 
                    icon={<TrendingDownIcon />} 
                    iconPosition="start"
                    sx={{ textTransform: 'none' }}
                  />
                  <Tab 
                    label="AI Assistant" 
                    icon={<SmartToyIcon />} 
                    iconPosition="start"
                    sx={{ textTransform: 'none' }}
                  />
                </Tabs>
              </Box>

              {/* Risk Reduction Tab */}
              {activeTab === 0 && (
                <Box>
                  <Typography variant="h6" gutterBottom>
                    Risk Mitigation Strategy
                  </Typography>
                  <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
                    AI-powered analysis of optimal security improvements organized in implementation rounds for maximum risk reduction:
                  </Typography>

                  {(isAnalyzingReductions && !isUpdatingStrategy && !riskMitigationStrategy) ? (
                    <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', py: 4 }}>
                      <CircularProgress sx={{ mb: 2 }} />
                      <Typography variant="body2" color="text.secondary">
                        Analyzing optimal risk mitigation strategy...
                    </Typography>
                    </Box>
                  ) : riskMitigationStrategy ? (
                    <Box>
                      {/* Current Round Details */}
                      {(() => {
                        const round = riskMitigationStrategy.rounds[selectedRound];
                        if (!round) return null;
                        return (
                          <Paper variant="outlined" sx={{ p: 3, mb: 3 }}>
                            <Typography variant="h6" gutterBottom>
                              Round {round.roundNumber} - Implementation Details
                            </Typography>
                            <Grid container spacing={2} sx={{ mb: 2 }}>
                              <Grid item xs={6} sm={3}>
                                <Typography variant="body2" color="text.secondary">Risk Reduction</Typography>
                                <Typography variant="h6" color="success.main">
                                  -{round.reductionPercentage.toFixed(1)}%
                                </Typography>
                              </Grid>
                              <Grid item xs={6} sm={3}>
                                <Typography variant="body2" color="text.secondary">Current Risk</Typography>
                                <Typography variant="h6">
                                  {(round.currentRisk * 100).toFixed(0)}%
                                </Typography>
                              </Grid>
                              <Grid item xs={6} sm={3}>
                                <Typography variant="body2" color="text.secondary">Projected Risk</Typography>
                                <Typography variant="h6" color="primary.main">
                                  {(round.projectedRisk * 100).toFixed(0)}%
                                </Typography>
                              </Grid>
                              <Grid item xs={6} sm={3}>
                                <Typography variant="body2" color="text.secondary">Focus Areas</Typography>
                                <Typography variant="h6">
                                  {round.features.length}
                                </Typography>
                              </Grid>
                            </Grid>
                            {/* Sorting Dropdown and Next Round Button */}
                            <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2 }}>
                              <FormControl size="small" sx={{ minWidth: 180 }}>
                                <InputLabel>Sort by</InputLabel>
                                <Select
                                  value={sortBy}
                                  label="Sort by"
                                  onChange={e => setSortBy(e.target.value)}
                                >
                                  <MenuItem value="default">Default Order</MenuItem>
                                  <MenuItem value="riskReduction">Risk Reduction</MenuItem>
                                  <MenuItem value="cost">Cost</MenuItem>
                                  <MenuItem value="priority">Priority</MenuItem>
                                </Select>
                              </FormControl>
                              {selectedRound < riskMitigationStrategy.rounds.length - 1 && (
                                <Button
                                  variant="contained"
                                  color="primary"
                                  onClick={() => setSelectedRound(selectedRound + 1)}
                                  sx={{ ml: 2 }}
                                >
                                  Continue to Next Round
                                </Button>
                              )}
                            </Box>
                            {/* Recommendations List */}
                            <Box>
                              {getSortedRecommendations(round.recommendations, sortBy).map((rec, idx) => {
                                const percent = rec.riskReductionPercentage ?? 0;
                                let color = '#4caf50';
                                if (percent < 10) color = '#f44336';
                                else if (percent < 20) color = '#ff9800';
                                return (
                                  <Card key={idx} sx={{ mb: 2, display: 'flex', alignItems: 'center', p: 2 }}>
                                    <Box sx={{ flex: 1 }}>
                                      <Typography variant="subtitle1" fontWeight="bold">
                                        {rec.featureName}
                                      </Typography>
                                      <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                                        {rec.description}
                                      </Typography>
                                      <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
                                        <Chip label={`Current: ${rec.currentOption}`} size="small" />
                                        <Chip label={`Recommended: ${rec.recommendedOption}`} size="small" color="primary" />
                                      </Box>
                                      <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
                                        <Chip label={`Cost: ${'$'.repeat(rec.costLevel ?? 2)}`} size="small" />
                                        <Chip label={`Priority: ${rec.importance ?? 'Medium'}`} size="small" />
                                      </Box>
                                    </Box>
                                    <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', minWidth: 90 }}>
                                      <Box sx={{ position: 'relative', display: 'inline-flex', mb: 0.5 }}>
                                        <svg width={54} height={54}>
                                          <circle
                                            cx={27}
                                            cy={27}
                                            r={24}
                                            fill="none"
                                            stroke="#e0e0e0"
                                            strokeWidth={6}
                                          />
                                          <circle
                                            cx={27}
                                            cy={27}
                                            r={24}
                                            fill="none"
                                            stroke={color}
                                            strokeWidth={6}
                                            strokeDasharray={2 * Math.PI * 24}
                                            strokeDashoffset={2 * Math.PI * 24 * (1 - percent / 100)}
                                            strokeLinecap="round"
                                            style={{ transition: 'stroke-dashoffset 0.6s cubic-bezier(0.4,0,0.2,1)' }}
                                          />
                                        </svg>
                                        <Box sx={{
                                          position: 'absolute',
                                          top: 0,
                                          left: 0,
                                          width: '100%',
                                          height: '100%',
                                          display: 'flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                        }}>
                                          <Typography variant="subtitle2" sx={{ fontWeight: 700, color }}>
                                            {percent.toFixed(1)}%
                                          </Typography>
                                        </Box>
                                      </Box>
                                      <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 500 }}>
                                        Risk Reduction
                                      </Typography>
                                    </Box>
                                  </Card>
                                );
                              })}
                            </Box>
                          </Paper>
                        );
                      })()}
                    </Box>
                  ) : (
                    <Alert severity="info" sx={{ mb: 2 }}>
                      <Typography variant="body2">
                        Complete the risk assessment to generate a personalized mitigation strategy.
                      </Typography>
                    </Alert>
                  )}
                </Box>
              )}

              {/* AI Assistant Tab */}
              {activeTab === 1 && (
                <Box>
                                     <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                     <Typography variant="h6">
                       AI Risk Analysis Assistant
                     </Typography>
                     <Box sx={{ display: 'flex', gap: 1 }}>
                       <Button
                         variant="outlined"
                         size="small"
                         startIcon={<AddIcon />}
                         onClick={handleNewChat}
                       >
                         New Chat
                       </Button>
                       <Button
                         variant="outlined"
                         size="small"
                         startIcon={<HistoryIcon />}
                         onClick={() => setIsChatSidebarOpen(true)}
                       >
                         History
                       </Button>
                       <Tooltip 
                         title={!currentConversation || currentConversation.messages.length <= 1 
                           ? "Start a conversation to export chat history" 
                           : "Export conversation as PDF with risk context"}
                         arrow
                       >
                         <span>
                           <Button
                             variant="outlined"
                             size="small"
                             startIcon={<DownloadIcon />}
                             onClick={handleExportChat}
                             disabled={!currentConversation || currentConversation.messages.length <= 1}
                           >
                             Export Chat
                           </Button>
                         </span>
                       </Tooltip>
                     </Box>
                   </Box>

                  <Box sx={{ display: 'flex', gap: 3 }}>
                    {/* Chat Interface */}
                    <Box sx={{ flex: 2 }}>
                      <Paper elevation={1} sx={{ height: '500px', display: 'flex', flexDirection: 'column' }}>
                        <Box sx={{ p: 2, borderBottom: 1, borderColor: 'divider', bgcolor: 'primary.main', color: 'white' }}>
                          <Typography variant="subtitle1" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            <SmartToyIcon />
                            Risk Analysis Chat
                          </Typography>
                        </Box>
                        
                        <Box sx={{ flexGrow: 1, overflow: 'auto', p: 2 }}>
                          {currentConversation?.messages.map((message) => (
                            <Box
                              key={message.id}
                              sx={{
                                display: 'flex',
                                flexDirection: message.sender === 'user' ? 'row-reverse' : 'row',
                                alignItems: 'flex-start',
                                mb: 2,
                                gap: 1,
                                width: '100%'
                              }}
                            >
                                <Avatar sx={{ 
                                  bgcolor: message.sender === 'user' ? 'primary.main' : 'secondary.main',
                                  width: 36,
                                height: 36,
                                flexShrink: 0
                                }}>
                                  {message.sender === 'user' ? <PersonIcon /> : <SmartToyIcon />}
                                </Avatar>
                              
                              <Box sx={{ 
                                maxWidth: 'calc(100% - 50px)', // Account for avatar and gap
                                minWidth: 0,
                                width: 'fit-content'
                              }}>
                                                             <Paper
                                  elevation={2}
                                 sx={{
                                    p: 1.5,
                                   bgcolor: message.sender === 'user' ? 'primary.light' : 'background.paper',
                                   border: message.sender === 'ai' ? 1 : 0,
                                   borderColor: message.sender === 'ai' ? 'divider' : 'transparent',
                                    borderRadius: message.sender === 'user' ? '18px 18px 4px 18px' : '18px 18px 18px 4px',
                                    position: 'relative',
                                    overflow: 'hidden',
                                    boxShadow: (theme) => theme.palette.mode === 'dark' 
                                      ? '0 2px 8px rgba(0,0,0,0.3)' 
                                      : '0 1px 3px rgba(0,0,0,0.1)',
                                 }}
                               >
                                 <Typography 
                                   variant="body2" 
                                    component="div"
                                   sx={{ 
                                     color: message.sender === 'user' ? 'white' : 'text.primary',
                                      lineHeight: 1.4,
                                      wordBreak: 'break-word',
                                      whiteSpace: 'pre-wrap',
                                     '& strong': {
                                       fontWeight: 'bold',
                                       color: message.sender === 'user' ? 'white' : 'primary.main'
                                     },
                                     '& em': {
                                       fontStyle: 'italic'
                                      }
                                    }}
                                  >
                                    <MessageContent message={message} />
                                  </Typography>
                                  
                                 <Typography 
                                   variant="caption" 
                                   sx={{ 
                                      color: message.sender === 'user' ? 'rgba(255,255,255,0.7)' : 'text.secondary',
                                      fontSize: '0.65rem',
                                      mt: 0.5,
                                      display: 'block',
                                      textAlign: message.sender === 'user' ? 'right' : 'left'
                                   }}
                                 >
                                   {message.timestamp.toLocaleTimeString()}
                                 </Typography>
                               </Paper>
                              </Box>
                            </Box>
                          ))}
                          
                          {/* Typing Animation */}
                          {isAiTyping && (
                            <Box
                              sx={{
                                display: 'flex',
                                flexDirection: 'row',
                                alignItems: 'flex-start',
                                mb: 2,
                                gap: 1,
                                width: '100%'
                              }}
                            >
                                <Avatar sx={{ 
                                  bgcolor: 'secondary.main',
                                  width: 36,
                                height: 36,
                                flexShrink: 0
                                }}>
                                  <SmartToyIcon />
                                </Avatar>
                              
                              <Box sx={{ 
                                maxWidth: 'calc(100% - 50px)',
                                minWidth: 0,
                                width: 'fit-content'
                              }}>
                              <Paper
                                  elevation={2}
                                sx={{
                                    p: 1.5,
                                  bgcolor: 'background.paper',
                                  border: 1,
                                  borderColor: 'divider',
                                    borderRadius: '18px 18px 18px 4px',
                                  display: 'flex',
                                  alignItems: 'center',
                                    gap: 1,
                                    position: 'relative',
                                    overflow: 'hidden',
                                    boxShadow: (theme) => theme.palette.mode === 'dark' 
                                      ? '0 2px 8px rgba(0,0,0,0.3)' 
                                      : '0 1px 3px rgba(0,0,0,0.1)',
                                }}
                              >
                                <TypingAnimation>
                                  <Box className="dot" />
                                  <Box className="dot" />
                                  <Box className="dot" />
                                </TypingAnimation>
                                <Typography variant="caption" color="text.secondary">
                                  Dr. CyberBuild is thinking...
                                </Typography>
                              </Paper>
                              </Box>
                            </Box>
                          )}
                        </Box>

                        <Divider />
                        
                        <Box sx={{ p: 2 }}>
                          <Box sx={{ display: 'flex', gap: 1 }}>
                            <TextField
                              fullWidth
                              size="small"
                              variant="outlined"
                              placeholder={isAiTyping ? "Dr. CyberBuild is responding..." : "Ask about your risk assessment results..."}
                              value={chatInput}
                              onChange={(e) => setChatInput(e.target.value)}
                              onKeyPress={(e) => e.key === 'Enter' && !isAiTyping && handleChatSend()}
                              disabled={isAiTyping}
                            />
                            <Button
                              variant="contained"
                              endIcon={isAiTyping ? <CircularProgress size={16} color="inherit" /> : <SendIcon />}
                              onClick={handleChatSend}
                              disabled={!chatInput.trim() || isAiTyping}
                            >
                              {isAiTyping ? 'Thinking...' : 'Send'}
                            </Button>
                          </Box>
                        </Box>
                      </Paper>
                    </Box>

                    {/* Chat Suggestions */}
                    <Box sx={{ flex: 1 }}>
                      <Paper 
                        elevation={1} 
                        sx={{ 
                          height: '500px', 
                          overflow: 'hidden',
                          display: 'flex',
                          flexDirection: 'column',
                          position: 'relative',
                          background: (theme) => theme.palette.mode === 'dark' 
                            ? 'linear-gradient(135deg, rgba(35, 41, 70, 0.95) 0%, rgba(35, 41, 70, 0.85) 100%)'
                            : 'linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(249, 250, 251, 0.95) 100%)',
                          backdropFilter: 'blur(20px)',
                          border: (theme) => theme.palette.mode === 'dark'
                            ? '1px solid rgba(99, 102, 241, 0.2)'
                            : '1px solid rgba(79, 70, 229, 0.1)',
                        }}
                      >
                        {/* Header */}
                        <Box sx={{ 
                          p: 1.5, 
                          borderBottom: 1, 
                          borderColor: (theme) => theme.palette.mode === 'dark' 
                            ? 'rgba(99, 102, 241, 0.2)'
                            : 'rgba(79, 70, 229, 0.1)',
                          background: (theme) => theme.palette.mode === 'dark'
                            ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(6, 182, 212, 0.15) 100%)'
                            : 'linear-gradient(135deg, rgba(79, 70, 229, 0.08) 0%, rgba(6, 182, 212, 0.08) 100%)',
                        }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                            <Box sx={{ 
                              display: 'flex', 
                              alignItems: 'center', 
                              gap: 1 
                            }}>
                              <motion.div
                                animate={{ 
                                  rotate: isLoadingQuestions ? 360 : 0,
                                }}
                                transition={{
                                  duration: 2,
                                  repeat: isLoadingQuestions ? Infinity : 0,
                                  ease: "linear"
                                }}
                              >
                                <SmartToyIcon 
                                  sx={{ 
                                    color: 'primary.main',
                                    fontSize: 18
                                  }} 
                                />
                              </motion.div>
                              <Typography 
                                variant="subtitle2" 
                                sx={{ 
                                  fontWeight: 600,
                                  background: (theme) => theme.palette.mode === 'dark'
                                    ? 'linear-gradient(135deg, #ffffff 0%, #e5e7eb 100%)'
                                    : 'linear-gradient(135deg, #1e293b 0%, #475569 100%)',
                                  backgroundClip: 'text',
                                  WebkitBackgroundClip: 'text',
                                  WebkitTextFillColor: 'transparent',
                                }}
                              >
                                Recommended Questions
                        </Typography>
                            </Box>
                            {isLoadingQuestions && (
                              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                <CircularProgress 
                                  size={14} 
                                  sx={{ 
                                    color: 'primary.main',
                                    opacity: 0.8
                                  }} 
                                />
                                <Typography 
                                  variant="caption" 
                                  sx={{ 
                                    color: 'primary.main',
                                    fontWeight: 500,
                                    fontSize: '0.7rem'
                                  }}
                                >
                                  Generating...
                        </Typography>
                              </Box>
                            )}
                          </Box>
                        </Box>
                        
                        {/* Questions List */}
                        <Box sx={{ 
                          flex: 1, 
                          overflow: 'auto', 
                          p: 1,
                          '&::-webkit-scrollbar': {
                            width: '6px',
                          },
                          '&::-webkit-scrollbar-track': {
                            background: (theme) => theme.palette.mode === 'dark' 
                              ? 'rgba(255, 255, 255, 0.05)'
                              : 'rgba(0, 0, 0, 0.05)',
                            borderRadius: '3px',
                          },
                          '&::-webkit-scrollbar-thumb': {
                            background: (theme) => theme.palette.mode === 'dark'
                              ? 'rgba(99, 102, 241, 0.3)'
                              : 'rgba(79, 70, 229, 0.3)',
                            borderRadius: '3px',
                            '&:hover': {
                              background: (theme) => theme.palette.mode === 'dark'
                                ? 'rgba(99, 102, 241, 0.5)'
                                : 'rgba(79, 70, 229, 0.5)',
                            },
                          },
                        }}>
                          <AnimatePresence mode="popLayout">
                            {recommendedQuestions.map((question, index) => (
                              <motion.div
                                key={`${question}-${index}`}
                                layout
                                initial={{ 
                                  opacity: 0, 
                                  x: -30,
                                  scale: 0.95
                                }}
                                animate={{ 
                                  opacity: 1, 
                                  x: 0,
                                  scale: 1
                                }}
                                exit={{
                                  opacity: 0,
                                  x: 30,
                                  scale: 0.95,
                                  transition: { duration: 0.2 }
                                }}
                                transition={{
                                  duration: 0.5,
                                  delay: index * 0.08,
                                  ease: [0.25, 0.46, 0.45, 0.94],
                                  layout: { duration: 0.3 }
                                }}
                                whileHover={{
                                  scale: 1.02,
                                  transition: { duration: 0.2 }
                                }}
                                whileTap={{
                                  scale: 0.98,
                                  transition: { duration: 0.1 }
                                }}
                              >
                                <Card
                              onClick={() => setChatInput(question)}
                              sx={{ 
                                    mb: 0.8,
                                    cursor: 'pointer',
                                    position: 'relative',
                                    overflow: 'hidden',
                                    background: (theme) => theme.palette.mode === 'dark'
                                      ? 'linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(51, 65, 85, 0.6) 100%)'
                                      : 'linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 250, 252, 0.9) 100%)',
                                    border: (theme) => theme.palette.mode === 'dark'
                                      ? '1px solid rgba(99, 102, 241, 0.2)'
                                      : '1px solid rgba(79, 70, 229, 0.15)',
                                    backdropFilter: 'blur(10px)',
                                    transition: 'all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)',
                                    '&:hover': { 
                                      background: (theme) => theme.palette.mode === 'dark'
                                        ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.25) 0%, rgba(139, 92, 246, 0.25) 100%)'
                                        : 'linear-gradient(135deg, rgba(79, 70, 229, 0.08) 0%, rgba(99, 102, 241, 0.08) 100%)',
                                      borderColor: (theme) => theme.palette.mode === 'dark'
                                        ? 'rgba(99, 102, 241, 0.4)'
                                        : 'rgba(79, 70, 229, 0.3)',
                                      transform: 'translateY(-2px)',
                                      boxShadow: (theme) => theme.palette.mode === 'dark'
                                        ? '0 8px 32px rgba(99, 102, 241, 0.3)'
                                        : '0 8px 32px rgba(79, 70, 229, 0.15)',
                                    },
                                    '&:active': {
                                      transform: 'translateY(0px)',
                                    },
                                    // Subtle gradient border effect
                                    '&::before': {
                                      content: '""',
                                      position: 'absolute',
                                      top: 0,
                                      left: 0,
                                      right: 0,
                                      height: '2px',
                                      background: (theme) => theme.palette.mode === 'dark'
                                        ? 'linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.6), transparent)'
                                        : 'linear-gradient(90deg, transparent, rgba(79, 70, 229, 0.4), transparent)',
                                      opacity: 0,
                                      transition: 'opacity 0.3s ease',
                                    },
                                    '&:hover::before': {
                                      opacity: 1,
                                    }
                                  }}
                                >
                                  <CardContent sx={{ p: 1.5, '&:last-child': { pb: 1.5 } }}>
                                    <Box sx={{ 
                                      display: 'flex', 
                                      alignItems: 'center', 
                                      gap: 1.5,
                                      width: '100%' 
                                    }}>
                                      <motion.div
                                        initial={{ rotate: 0, scale: 1 }}
                                        whileHover={{ rotate: 5, scale: 1.1 }}
                                        transition={{ duration: 0.2 }}
                                      >
                                        <Box sx={{
                                          width: 32,
                                          height: 32,
                                          borderRadius: '8px',
                                          display: 'flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                          background: (theme) => theme.palette.mode === 'dark'
                                            ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%)'
                                            : 'linear-gradient(135deg, rgba(79, 70, 229, 0.1) 0%, rgba(99, 102, 241, 0.1) 100%)',
                                          border: (theme) => theme.palette.mode === 'dark'
                                            ? '1px solid rgba(99, 102, 241, 0.3)'
                                            : '1px solid rgba(79, 70, 229, 0.2)',
                                        }}>
                                          <ChatBubbleOutlineIcon 
                                            sx={{ 
                                              fontSize: 16,
                                              color: 'primary.main',
                                            }} 
                                          />
                                        </Box>
                                      </motion.div>
                                      
                                      <Typography 
                                        variant="body2"
                                        sx={{ 
                                          fontWeight: 500,
                                          lineHeight: 1.4,
                                          flex: 1,
                                          color: (theme) => theme.palette.mode === 'dark'
                                            ? 'rgba(255, 255, 255, 0.9)'
                                            : 'text.primary',
                                        }}
                                      >
                                        {question}
                                      </Typography>
                                      
                                      <motion.div
                                        initial={{ opacity: 0, x: -8 }}
                                        whileHover={{ opacity: 1, x: 0 }}
                                        transition={{ duration: 0.2 }}
                                      >
                                        <Box sx={{
                                          width: 24,
                                          height: 24,
                                          borderRadius: '6px',
                                          display: 'flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                          background: (theme) => theme.palette.mode === 'dark'
                                            ? 'rgba(99, 102, 241, 0.2)'
                                            : 'rgba(79, 70, 229, 0.1)',
                                        }}>
                                          <ArrowForwardIcon 
                                            sx={{ 
                                              fontSize: 14,
                                              color: 'primary.main',
                                            }} 
                                          />
                                        </Box>
                                      </motion.div>
                                    </Box>
                                  </CardContent>
                                </Card>
                              </motion.div>
                            ))}
                                                    </AnimatePresence>
                        </Box>
                        
                        {/* Risk Context Section */}
                        <Box sx={{ 
                          px: 1.5, 
                          py: 1,
                          borderTop: 1, 
                          borderColor: (theme) => theme.palette.mode === 'dark' 
                            ? 'rgba(99, 102, 241, 0.2)'
                            : 'rgba(79, 70, 229, 0.1)',
                          background: (theme) => theme.palette.mode === 'dark'
                            ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(6, 182, 212, 0.05) 100%)'
                            : 'linear-gradient(135deg, rgba(79, 70, 229, 0.03) 0%, rgba(6, 182, 212, 0.03) 100%)',
                        }}>
                          <Typography variant="caption" sx={{ 
                            fontWeight: 600,
                            color: 'text.secondary',
                            fontSize: '0.65rem',
                            mb: 0.3,
                            display: 'block'
                          }}>
                            🎯 Risk Context
                        </Typography>
                          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.3 }}>
                          {Object.entries(riskResults).map(([risk, analysis]) => (
                              <motion.div
                              key={risk}
                                initial={{ opacity: 0, scale: 0.9 }}
                                animate={{ opacity: 1, scale: 1 }}
                                transition={{ duration: 0.2, delay: Object.keys(riskResults).indexOf(risk) * 0.05 }}
                                whileHover={{ scale: 1.03 }}
                                whileTap={{ scale: 0.97 }}
                              >
                                <Box
                              onClick={() => setChatInput(`Tell me more about my ${risk} risk score of ${analysis.score}%`)}
                                  sx={{ 
                                    cursor: 'pointer',
                                    '& .MuiChip-root': {
                                      height: '18px',
                                      fontSize: '0.6rem',
                                      '& .MuiChip-label': {
                                        px: 0.5,
                                        py: 0
                                      }
                                    }
                                  }}
                            >
                              <RiskContextBadge
                                riskType={risk.replace(/([A-Z])/g, ' $1').trim()}
                                score={analysis.score}
                            />
                            </Box>
                              </motion.div>
                          ))}
                          </Box>
                        </Box>
                      </Paper>
                    </Box>
                  </Box>
                </Box>
              )}
            </Paper>
          </motion.div>
        )}

        {/* Chat History Drawer */}
        <Drawer
          anchor="right"
          open={isChatSidebarOpen}
          onClose={() => setIsChatSidebarOpen(false)}
        >
          <Box sx={{ width: 350, p: 2 }}>
            <Typography variant="h6" gutterBottom>
              Chat History
            </Typography>
            <List>
              {conversations.map((conversation) => (
                <ListItem
                  key={conversation.id}
                  button
                  selected={conversation.id === currentConversationId}
                  onClick={() => {
                    setCurrentConversationId(conversation.id);
                    setIsChatSidebarOpen(false);
                  }}
                  sx={{ borderRadius: 1, mb: 1 }}
                >
                  <ListItemText
                    primary={conversation.title}
                    secondary={conversation.lastUpdated.toLocaleString()}
                  />
                </ListItem>
              ))}
            </List>
          </Box>
        </Drawer>

        <Box sx={{ display: 'flex', justifyContent: 'center', gap: 2, mt: 4 }}>
          <Tooltip 
            title={!isFormComplete() ? "Complete all required fields to export report" : "Export PDF report"}
            arrow
          >
            <span>
              <Button
                variant="contained"
                startIcon={<DownloadIcon />}
                onClick={exportToPDF}
                disabled={!isFormComplete()}
              >
                Export Report
              </Button>
            </span>
          </Tooltip>
          <Tooltip 
            title={!isFormComplete() ? "Complete all required fields to save project" : "Save project to your account"}
            arrow
          >
            <span>
              <Button
                variant="contained"
                startIcon={<SaveIcon />}
                onClick={handleSaveProject}
                disabled={!isFormComplete()}
              >
                Save
              </Button>
            </span>
          </Tooltip>
        </Box>

        {/* Save Project Dialog */}
        <Dialog open={saveDialogOpen} onClose={handleSaveCancel} maxWidth="sm" fullWidth>
          <DialogTitle>Save Project</DialogTitle>
          <DialogContent>
            <Box sx={{ pt: 1 }}>
              <TextField
                autoFocus
                fullWidth
                label="Project Name"
                value={projectName}
                onChange={(e) => setProjectName(e.target.value)}
                placeholder="Enter a unique name for your project"
                error={!!saveError}
                helperText={saveError}
                disabled={isSaving}
              />
              
              {saveSuccess && (
                <Alert severity="success" sx={{ mt: 2 }}>
                  Project saved successfully! You can find it in the Reports section.
                </Alert>
              )}
              
              <Box sx={{ mt: 2 }}>
                <Typography variant="body2" color="text.secondary">
                  This will save:
                </Typography>
                <Box component="ul" sx={{ mt: 1, pl: 2 }}>
                  <Typography component="li" variant="body2" color="text.secondary">
                    Project configuration and details
                  </Typography>
                  <Typography component="li" variant="body2" color="text.secondary">
                    Risk analysis results
                  </Typography>
                  <Typography component="li" variant="body2" color="text.secondary">
                    Risk mitigation strategies
                  </Typography>
                  <Typography component="li" variant="body2" color="text.secondary">
                    All chatbot conversations
                  </Typography>
                </Box>
              </Box>
            </Box>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleSaveCancel} disabled={isSaving}>
              Cancel
            </Button>
            <Button 
              onClick={handleSaveConfirm} 
              variant="contained" 
              disabled={isSaving || !projectName.trim()}
              startIcon={isSaving ? <CircularProgress size={20} /> : <SaveIcon />}
            >
              {isSaving ? 'Saving...' : 'Save Project'}
            </Button>
          </DialogActions>
        </Dialog>
      </motion.div>
    </Container>
  );
};

export default RiskQuantification; 
